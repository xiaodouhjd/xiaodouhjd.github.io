<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小豆的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-02T08:50:30.964Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jindou Hou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue基本掌握内容</title>
    <link href="http://yoursite.com/2019/06/02/vue%E5%9F%BA%E6%9C%AC%E6%8E%8C%E6%8F%A1%E5%86%85%E5%AE%B9/"/>
    <id>http://yoursite.com/2019/06/02/vue基本掌握内容/</id>
    <published>2019-06-02T08:24:18.000Z</published>
    <updated>2019-06-02T08:50:30.964Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-数据监测不到更新操作-和-列表渲染的维护状态"><a href="#1-数据监测不到更新操作-和-列表渲染的维护状态" class="headerlink" title="1-数据监测不到更新操作 和 列表渲染的维护状态"></a>1-数据监测不到更新操作 和 列表渲染的维护状态</h3><h4 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">使用一些变异方法或者直接替换数组都能引起页面的更新。</span><br><span class="line"></span><br><span class="line">但是以下两个操作不会：</span><br><span class="line">  1. 直接根据数据下标来修改     vm.list[0] = 9;</span><br><span class="line">  2. 直接修改数据的长度         vm.list.length = 10;</span><br><span class="line"></span><br><span class="line">解决方式：</span><br><span class="line"></span><br><span class="line">  1. 使用 Vue.set 原型方法</span><br><span class="line">  2. 使用 vm.$set 实例方法</span><br><span class="line"></span><br><span class="line">  Vue.set(target, index, value);</span><br><span class="line">  vm.$set(target, index, value);</span><br></pre></td></tr></table></figure><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue 不能检测对象属性的添加或删除：</span><br><span class="line"></span><br><span class="line">Vue.set(target, key, value);</span><br><span class="line">vm.$set(target, key, value);</span><br></pre></td></tr></table></figure><h3 id="列表渲染的维护状态"><a href="#列表渲染的维护状态" class="headerlink" title="列表渲染的维护状态"></a>列表渲染的维护状态</h3><ul><li>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似 Vue 1.x 的 track-by=”$index” 。</li><li>这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。</li><li><p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;item in items&quot; v-bind:key=&quot;item.id&quot;&gt;</span><br><span class="line">  &lt;!-- 内容 --&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</li><li>因为它是 Vue 识别节点的一个通用机制，key 并不与 v-for 特别关联，key 还具有其他用途，我们将在后面的指南中看到其他用途。</li><li>不要使用对象或数组之类的非原始类型值作为 v-for 的 key。用字符串或数类型的值取而代之。</li></ul><h3 id="v-if-与-v-show-的区别："><a href="#v-if-与-v-show-的区别：" class="headerlink" title="v-if 与 v-show 的区别："></a>v-if 与 v-show 的区别：</h3><pre><code>1. 他们都能实现元素的显示隐藏2. v-show只是简单控制元素的display属性（不管条件为真还是为假，这个元素都会被渲染出来），而v-if才是条件渲染（条件为真，元素将会被渲染，条件为假，元素会被销毁）3. v-show有更高的首次渲染开销。v-if的首次渲染开销要小得多。4. v-if有更高的切换开销，v-show切换开销小5. v-if有配套的 v-else-if 和 v-else，而v-show没有6. v-if可以搭配template使用。而v-show不行。</code></pre></li></ul><h3 id="在-元素上使用-v-if-条件渲染分组"><a href="#在-元素上使用-v-if-条件渲染分组" class="headerlink" title="在  元素上使用 v-if 条件渲染分组"></a>在 <template> 元素上使用 v-if 条件渲染分组</template></h3><p>因为 v-if 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 <template> 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 <template> 元素。<br><strong>优点是:不影响内部布局。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;ok&quot;&gt;</span><br><span class="line">  &lt;h1&gt;Title&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 1&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure></template></template></p><h3 id="key-管理复用"><a href="#key-管理复用" class="headerlink" title="key 管理复用"></a>key 管理复用</h3><p><label> 元素仍然会被高效地复用，因为它们没有添加 key 属性。添加key属性就不会复用了。</label></p><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><ul><li>.stop</li><li>.prevent</li><li>.capture</li><li>.self.</li><li>once</li><li>.passive<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 阻止单击事件继续传播 --&gt;</span><br><span class="line">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只有修饰符 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span><br><span class="line">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span><br><span class="line">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span><br><span class="line">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br><span class="line">&lt;!-- self修饰符规定的就是，这个事件只能在绑定事件的元素身上起效果。在他的内部元素身上触发事件是不生效的。。他的原理就是判断  target === currentTarget --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 点击事件将只会触发一次 --&gt;</span><br><span class="line">&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt; </span><br><span class="line">&lt;!-- 而不会等待 `onScroll` 完成 --&gt; </span><br><span class="line">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt; </span><br><span class="line">&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><p>在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span><br><span class="line">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>你可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-on:keyup.page-down=&quot;onPageDown&quot;&gt;</span><br></pre></td></tr></table></figure></p><h3 id="按键码"><a href="#按键码" class="headerlink" title="按键码"></a>按键码</h3><ul><li>.enter</li><li>.tab</li><li>.delete (捕获“删除”和“退格”键)</li><li>.esc</li><li>.space</li><li>.up</li><li>.down</li><li>.left</li><li>.right<br><strong>注意：有一些按键 (.esc 以及所有的方向键) 在 IE9 中有不同的 key 值, 如果你想支持 IE9，这些内置的别名应该是首选。你还可以通过全局 config.keyCodes 对象自定义</strong></li></ul><p>你还可以通过全局 config.keyCodes 对象自定义按键修饰符别名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 可以使用 `v-on:keyup.f1`</span><br><span class="line">Vue.config.keyCodes.f1 = 112</span><br></pre></td></tr></table></figure></p><h3 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h3><p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p><ul><li>.ctrl</li><li>.alt</li><li>.shift</li><li>.meta</li></ul><h4 id="exact-修饰符"><a href="#exact-修饰符" class="headerlink" title="exact 修饰符"></a>exact 修饰符</h4><p>修饰符允许你控制由精确的系统修饰符组合触发的事件</p><h5 id="鼠标按钮修饰符2-2-0-新增"><a href="#鼠标按钮修饰符2-2-0-新增" class="headerlink" title="鼠标按钮修饰符2.2.0 新增"></a>鼠标按钮修饰符2.2.0 新增</h5><ul><li>.left</li><li>.right</li><li>.middle</li></ul><h3 id="v-bind-class"><a href="#v-bind-class" class="headerlink" title="v-bind:class"></a>v-bind:class</h3><ol><li><p>直接使用data的数据，数据是个字符串，这个数据的字符串会直接当做class类名。</p></li><li><p>使用 对象 字面量的事项<br>key: value, key会作为类名，value会转换成boolean类型，如果为真，这个key就会存在，如果为假，这个key就不存在</p></li><li><p>使用 数组的方式</p></li></ol><h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><p>事件绑定的时候，事件处理函数如果没有加括号，那么我们的事件处理函数会自动接收到 event 事件对象</p><p>如果加上括号，那么 event 对象不会自动传递，如果需要，得手动传递，$event</p><h2 id="表单绑定"><a href="#表单绑定" class="headerlink" title="表单绑定"></a>表单绑定</h2><p>你可以用 v-model 指令在表单 input、textarea 及 select 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。<br><strong>注意：v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。</strong><br>v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 value 属性和 input 事件；</li><li>checkbox 和 radio 使用 checked 属性和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul><p><strong>对于需要使用输入法 (如中文、日文、韩文等) 的语言，你会发现 v-model 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用 input 事件。</strong></p><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p><a href="https://cn.vuejs.org/v2/guide/computed.html" target="_blank" rel="noopener">参考</a><br>计算属性，能对现有的data中或者现有的计算属性中的数据做二次处理（计算）。并返回新的数据，这个计算属性可以当做 data 里面的数据一样在页面中或者其他的方法中去使用。<br><strong>但是有一点，计算属性不能直接修改</strong>。。。。<br>他的变化，是基于它的依赖项来的。它的依赖如果发生变化，那么他会重新计算。<br>计算属性vs方法<br> 计算属性有缓存，如果依赖项没有变化，那么相同的计算属性我使用多次，只会在第一次的时候执行。后续都是直接拿的缓存。而方法没有缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123; key, value &#125;</span><br><span class="line">       // key - 计算属性的名字，</span><br><span class="line">       // value - 是一个函数 , 他其实就是  amsg 这个计算属性的 getter</span><br></pre></td></tr></table></figure><h3 id="监听：-watch"><a href="#监听：-watch" class="headerlink" title="监听： watch."></a>监听： watch.</h3><p>监听现有的data或computed中的数据，如果监听的数据有变化，那么监听的回调函数将会被执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123; key,value&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  // key - 要监听的数据</span><br><span class="line">  // value - 监听的回调函数 会接收两个参数，newVal, oldVal</span><br><span class="line">  watch: &#123;</span><br><span class="line">  msg (newVal, oldVal) &#123;</span><br><span class="line">    console.log(&apos;newVal: &apos;, newVal);</span><br><span class="line">    console.log(&apos;oldVal: &apos;, oldVal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin 混入"></a>mixin 混入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> var common = &#123;&#125;</span><br><span class="line">//定义一个对象，这个对象就是包含有vue组件实例相关的选项的一个对象。</span><br><span class="line">/data如果是一个混入对象的选项，那么data需要使用工厂模式</span><br><span class="line">      // 弄成一个方法，方法里面返回对象</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 使用混入</span><br><span class="line">     mixins: [common],</span><br></pre></td></tr></table></figure><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p><a href="https://cn.vuejs.org/v2/guide/components-registration.html" target="_blank" rel="noopener">参考</a><br>使用组件</p><ol><li>创建组件</li><li>全局注册  Vue.component(组件的名字，组件的选项对象)<ol start="2"><li>局部注册  components 选项<h4 id="全局与局部的区别："><a href="#全局与局部的区别：" class="headerlink" title="全局与局部的区别："></a>全局与局部的区别：</h4></li><li>在谁的身上注册的局部组件，就只能用在这个人的身上。</li><li>全局注册的组件可以用在任意位置。必须要在 new Vue 之前去注册。 </li><li>把组件当做一个自定义标签去使用<h4 id="组件的特性"><a href="#组件的特性" class="headerlink" title="组件的特性"></a>组件的特性</h4>这里写法跟 mixin 很像，都是能够使用 new Vue 时传递的哪些选项。<ol><li>el 与 propsData 不能用</li><li>data 必须是一个函数返回对象的形式。</li><li>组件必须要有一个选项是，template 选项，这个选项指定我们组件的内容。</li></ol></li></ol></li></ol><h3 id="组件的一些使用情况："><a href="#组件的一些使用情况：" class="headerlink" title="组件的一些使用情况："></a>组件的一些使用情况：</h3><ol><li>组件的使用，先注册，然后用组件的名字做为标签来使用。</li><li>组件必须要有一个 template 选项，来指定这个组件的模板内容。</li><li>组件的 data 选项 必须是一个函数返回对象的形式。</li><li>组件的命名，可以尽量 短横线方式。<br>也可以使用 驼峰的方式，但是使用的时候需要换成 短横线方式。 （todo）<ul><li><ol><li>使用 x-template 的 script 标签的方式的时候，不需要考虑这条规则</li></ol></li><li><ol start="2"><li>使用 单文件组件， 也不需要考虑这条规则</li></ol></li></ul></li><li>组件的命名不能跟现有的html标签冲突</li><li>组件的 template 选项只能有一个 根元素</li><li>全局注册的组件 Vue.componet 必须写在 new Vue 之前。</li></ol><p><strong>vue 实例也可以设置 template 选项，当有tempalte选项的时候，挂载点会整个被tempalte模板内容给替换。</strong></p><h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ComponentA = &#123; /* ... */ &#125;</span><br></pre></td></tr></table></figure><h4 id="template写法"><a href="#template写法" class="headerlink" title="template写法"></a>template写法</h4><ol><li>直接使用 模板字符串的方式<ol start="2"><li>使用单文件组件   （推荐）</li><li>使用 script 标签的方式</li></ol></li></ol><h3 id="组件的通信"><a href="#组件的通信" class="headerlink" title="组件的通信"></a>组件的通信</h3><h4 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h4><p>我们可以通过 Prop 向子组件传递数据。用一个形象的比喻来说，父子组件之间的数据传递相当于自上而下的下水管子，只能从上往下流，不能逆流。这也正是 Vue 的设计理念之单向数据流。</p><h4 id="emit"><a href="#emit" class="headerlink" title="$emit"></a>$emit</h4><p>$emit英式发音：[iˈmɪt]。官方说法是触发当前实例上的事件。附加参数都会传给监听器回调。按照我的理解不知道能不能给大家说明白，先简单看下代码吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;my-button @greet=&quot;sayHi&quot;&gt;&lt;/my-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  复制代码let MyButton = Vue.extend(&#123;</span><br><span class="line">  template: &apos;&lt;button @click=&quot;triggerClick&quot;&gt;click&lt;/button&gt;&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      greeting: &apos;vue.js!&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    triggerClick () &#123;</span><br><span class="line">      this.$emit(&apos;greet&apos;, this.greeting)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    MyButton</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sayHi (val) &#123;</span><br><span class="line">      alert(&apos;Hi, &apos; + val) // &apos;Hi, vue.js!&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>复制代码你可以狠狠的戳这里查看Demo! 大致逻辑是酱婶儿的：当我在页面上点击按钮时，触发了组件 MyButton 上的监听事件 greet，并且把参数传给了回调函数 sayHi 。说白了，当我们从子组件 Emit（派发） 一个事件之前，其内部都提前在事件队列中 On（监听）了这个事件及其监听回调。其实相当于下面这种写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$on(&apos;greet&apos;, function sayHi (val) &#123;</span><br><span class="line">  console.log(&apos;Hi, &apos; + val)</span><br><span class="line">&#125;)</span><br><span class="line">vm.$emit(&apos;greet&apos;, &apos;vue.js&apos;)</span><br><span class="line">// =&gt; &quot;Hi, vue.js&quot;</span><br></pre></td></tr></table></figure></p><h3 id="watch的特殊情况"><a href="#watch的特殊情况" class="headerlink" title="watch的特殊情况"></a>watch的特殊情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">//1,全局监听</span><br><span class="line">        msg (newVal, oldVal) &#123;</span><br><span class="line">          console.log(&apos;msg 改变了&apos;);</span><br><span class="line">        &#125;,</span><br><span class="line">//2深入监听</span><br><span class="line">        // userInfo: &#123;</span><br><span class="line">        //   handler (newVal, oldVal) &#123;</span><br><span class="line">        //     console.log(&apos;userInfo 改变了&apos;);</span><br><span class="line">        //   &#125;,</span><br><span class="line"></span><br><span class="line">        //   deep: true//深入监听</span><br><span class="line">        // &#125;</span><br><span class="line">//3指定监听</span><br><span class="line">        &apos;userInfo.name&apos;: [</span><br><span class="line">          function () &#123;</span><br><span class="line">            console.log(&apos;1&apos;)</span><br><span class="line">          &#125;,</span><br><span class="line"></span><br><span class="line">          function () &#123;</span><br><span class="line">            console.log(&apos;2&apos;)</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="props验证与默认值"><a href="#props验证与默认值" class="headerlink" title="props验证与默认值"></a>props验证与默认值</h3><p> 1数组模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: [&apos;title&apos;],</span><br></pre></td></tr></table></figure></p><p>  2对象模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">       // key - prop</span><br><span class="line">       // value - 好几种写法，可以对这个prop做一些类型校验。默认值处理之类的。</span><br><span class="line">       // title: String,    // title 字符串类型</span><br><span class="line"></span><br><span class="line">       title: &#123;</span><br><span class="line">         type: String,</span><br><span class="line">         default: &apos;关于页&apos;</span><br><span class="line">       &#125;,</span><br></pre></td></tr></table></figure></p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>ref 这个属性，可以写在 普通标签上，也可以写在组件标签上，</p><ol><li><p>普通标签，得到是这个标签的DOM对象</p><ol start="2"><li>组件标签，得到是这个组件的组件对象</li></ol><p>ref 用在哪个组件上，那么就需要使用哪个组件的 refs 去获取</p></li></ol><h3 id="组件的通信的特殊处理"><a href="#组件的通信的特殊处理" class="headerlink" title="组件的通信的特殊处理"></a>组件的通信的特殊处理</h3><p>触发事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$emit() // $emit 子 -&gt; 父</span><br></pre></td></tr></table></figure></p><p>监听事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$on()</span><br></pre></td></tr></table></figure></p><p>监听事件但是只监听一次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$once()</span><br></pre></td></tr></table></figure></p><p>除了使用 props 来做父-&gt;子</p><p> 还有一些特殊的操作：（但是不怎么推荐）</p><pre><code>1. ref 用在组件标签上2. $root 实例属性，可以拿到根组件的对象，也就是 new Vue 出来的实例3. $parent 实例属性，可以拿到当前组件的父组件的实例对象4. $children 实例属性，去获取子组件的实例，得到的是一个子组件实例的集合（Array）</code></pre><h3 id="兄弟组件之间与复杂关系组件之间的通信"><a href="#兄弟组件之间与复杂关系组件之间的通信" class="headerlink" title="兄弟组件之间与复杂关系组件之间的通信"></a>兄弟组件之间与复杂关系组件之间的通信</h3><p>事件总线 - 中央事件管理器 - bus</p><p>主要就是使用的 $on 与 $emit</p><p>通过一个空的vue实例对象来做为中央事件管理器。</p><h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;component :is=&quot;curTab&quot;&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure><h3 id="组件上使用v-model"><a href="#组件上使用v-model" class="headerlink" title="组件上使用v-model"></a>组件上使用v-model</h3><p>v-model 其实是一种语法糖。<br>在组件身上使用 v-model<br>需要 v-modle 绑定的数据可以在 组件中使用，并且可以通过某种形式直接去修改它。</p><ol><li>普通的事件并且是用在普通标签上的时候，$event 代表着事件对象 </li><li>如果事件是写在 组件的标签上面，$event 代表着触发这个事件的时候传递过来的参数<h3 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title="sync修饰符"></a>sync修饰符</h3></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$emit(&apos;update:title&apos;, newTitle)</span><br><span class="line"></span><br><span class="line">&lt;text-document v-bind:title.sync=&quot;doc.title&quot;&gt;&lt;/text-document&gt;</span><br></pre></td></tr></table></figure><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>默认在组件开始标签与结束标签中写的内容是不会理睬的。<br>如果需要将内容给渲染出去。就需要使用出 插槽(坑) slot</p><p>插槽模板内容： 使用组件时开始标签与闭合标签内的内容</p><p>使用顺序：</p><ol><li>思考 你的 插槽模板内容要显示在组件 template 模板的那个位置。。<ol start="2"><li>在 组件的 template 模板中 相应的位置 放置一个 slot 内置组件</li></ol></li><li><p>效果就会是：你这个插槽模板内容会替换 slot 这个组件并渲染到页面上。<br>一些情况：</p><ol><li>slot 是不限制次数的，</li><li>slot 是可以命名的。<br>slot 组件上 使用  name 属性给他命名<br>哪个插槽模板内容要放到哪个 slot 坑里面，就需要带着 name 的名字<ol start="3"><li>slot 还可以有个默认不加锁的 坑</li></ol></li></ol><h3 id="插槽的作用域"><a href="#插槽的作用域" class="headerlink" title="插槽的作用域"></a>插槽的作用域</h3><p>作用域插槽：（把组件内数据能够在插槽模板内容中使用）</p><p>使用步骤：</p></li><li><p>在 slot 标签上，写 自定义的属性，注意不能是 name2. 在 相应的 slot 的插槽模板内容上面 使用 slot-scope 接收 第一步中传递过来的 porp 集合。</p></li></ol><h3 id="插槽的新语法"><a href="#插槽的新语法" class="headerlink" title="插槽的新语法"></a>插槽的新语法</h3><p>旧的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p slot=&quot;abc&quot;&gt;我的天&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>新的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-slot:abc&gt;</span><br><span class="line">&lt;p&gt;我的地&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p><strong>一个不带 name 的 <slot> 出口会带有隐含的名字“default”</slot></strong><br><strong>v-slot:可以简写成#</strong><br><strong>v-slot 只能添加在一个 <template> 上 (只有一种例外情况)，这一点和已经废弃的 slot 特性不同。</template></strong></p><h3 id="非prop的特性"><a href="#非prop的特性" class="headerlink" title="非prop的特性"></a>非prop的特性</h3><p>非props特性: (在使用的组件的时候，在组件标签上写的特性，如果组件内部没有通过props选项去指定，那么这个 特性就叫做 非props特性), 非props特性会自动写入到组件的根元素上<br>非props特性替换的情况:<br>合并的情况：（class  yu  style）<br>禁用非props特性的自动写入到组件根元素上这个规则， 但是 class 与 style 除外。</p><ol><li>$attrs 与我们 inheritAttrs 没有关系。</li><li>$attrs 与 inheritAttrs 结合起来使用可以帮我们做一些事情，把这些非props特性写到组件的其他元素上。<br>基础组件：（将项目常用的一些基础html标签给做一个简单的封装。</li></ol><h3 id="生命周期图"><a href="#生命周期图" class="headerlink" title="生命周期图"></a>生命周期图</h3><p><img src="/2019/06/02/vue基本掌握内容/ce0b40b24af5aff99b5fc8c085a073ab.bmp" alt="图解"></p><h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p><p>执行 GET 请求// 为给定 ID 的 user 创建请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&apos;/user?ID=12345&apos;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">// 可选地，上面的请求可以这样做</span><br><span class="line">axios.get(&apos;/user&apos;, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: 12345</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">执行 POST 请求axios.post(&apos;/user&apos;, &#123;</span><br><span class="line">  firstName: &apos;Fred&apos;,</span><br><span class="line">  lastName: &apos;Flintstone&apos;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function (response) &#123;</span><br><span class="line">  console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以通过向 axios 传递相关配置来创建请求axios(config)//<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">发送 POST 请求axios(&#123;</span><br><span class="line">method: &apos;post&apos;,</span><br><span class="line">  url: &apos;/user/12345&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Fred&apos;,</span><br><span class="line">    lastName: &apos;Flintstone&apos;</span><br><span class="line">  &#125;&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-数据监测不到更新操作-和-列表渲染的维护状态&quot;&gt;&lt;a href=&quot;#1-数据监测不到更新操作-和-列表渲染的维护状态&quot; class=&quot;headerlink&quot; title=&quot;1-数据监测不到更新操作 和 列表渲染的维护状态&quot;&gt;&lt;/a&gt;1-数据监测不到更新操作 和
      
    
    </summary>
    
    
      <category term="vue基础" scheme="http://yoursite.com/tags/vue%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript运行机制</title>
    <link href="http://yoursite.com/2019/05/16/JavaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/16/JavaScript运行机制/</id>
    <published>2019-05-16T01:18:47.000Z</published>
    <updated>2019-06-02T08:50:28.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="你真懂JavaScript运行机制吗1？"><a href="#你真懂JavaScript运行机制吗1？" class="headerlink" title="你真懂JavaScript运行机制吗1？"></a>你真懂JavaScript运行机制吗1？</h1><p>说起javascript（以下简称js）这门语言，相信大家已经非常熟悉了，不管是前端开发还是后端开发几乎无时无刻都<br>要跟它打交道。虽说开发者每天几乎都要操作js，但是你真的确定你掌握了js的运行机制吗！下面我们就来聊聊这<br>话题。</p><h1 id="JavaScript运行机制图解"><a href="#JavaScript运行机制图解" class="headerlink" title="JavaScript运行机制图解"></a>JavaScript运行机制图解</h1><p><img src="/2019/05/16/JavaScript运行机制/图解.png" alt="图解"><br>上图我们可以分为两部分：浏览器中的 JS引擎 和 运行环境Runtime ，那它们的区别是什么？</p><ul><li>JS引擎：编译并执行代码的地方。<br>如上图中可以看出JS引擎分为两大核心部分： 栈和堆<br>栈（Stack）:js代码的执行都要压到此栈中执行。<br>堆：存放对象、数组的地方，js垃圾回收就是检查这里。</li><li>Runtime：浏览器的运行环境，它提供了一些对外接口供JS调用，以及跟外界打交道。</li></ul><h1 id="JavaScript引擎是单线程"><a href="#JavaScript引擎是单线程" class="headerlink" title="JavaScript引擎是单线程"></a>JavaScript引擎是单线程</h1><p>JS引擎是单线程的，也就是说在一个时间段内，事情只能一件一件的按先后顺序去做，第一件事没做完就不能第二<br>件事。那么在js引擎中负责解释和执行js代码的线程只有一个，我们可以称之为 主线程 。<br>当然浏览器的运行环境Runtime还提供一些其他的线程，如定时器线程、ajax线程、事件线程、网络请求和UI渲染<br>的线程，为了和js主线程分开，我们这里都统称它们为 工作线程 。<br>由于浏览器是多线程的，所以工作线程和js主线程都可以执行任务，线程间互不干扰。</p><h1 id="JavaScript引擎是单线程-1"><a href="#JavaScript引擎是单线程-1" class="headerlink" title="JavaScript引擎是单线程"></a>JavaScript引擎是单线程</h1><p>JS引擎是单线程的，也就是说在一个时间段内，事情只能一件一件的按先后顺序去做，第一件事没做完就不能第二<br>件事。那么在js引擎中负责解释和执行js代码的线程只有一个，我们可以称之为 主线程 。<br>当然浏览器的运行环境Runtime还提供一些其他的线程，如定时器线程、ajax线程、事件线程、网络请求和UI渲染<br>的线程，为了和js主线程分开，我们这里都统称它们为 工作线程 。<br>由于浏览器是多线程的，所以工作线程和js主线程都可以执行任务，线程间互不干扰。</p><h1 id="JavaScript同步（异步）任务"><a href="#JavaScript同步（异步）任务" class="headerlink" title="JavaScript同步（异步）任务"></a>JavaScript同步（异步）任务</h1><p>在JavaScript任务可以分为两种：</p><ul><li>同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务，若前一个任务耗<br>费很长时间，则后面的任务会一直处于等待状态，即阻塞状态。</li><li>异步任务：在栈执行代码的过程中，如遇到异步函数，如setTimeout、异步Ajax、事件处理程序，会将这些<br>异步代码交给浏览器的工作线程来处理，我们把这些任务称之为异步任务。异步任务是不进入主线程，而是<br>进入任务队列（queue task）。<ul><li>什么异步函数？<br>异步函数通常是由发起函数和回调函数构成的。如：<br>A（callback）<ul><li>函数A就是发起函数</li><li>callback就是回调函数<br>它们都是在主线程调用的，其中发起函数用来发起异步过程，回调函数用来处理结果。<br>如：<code>setTimeout(callback,1000)</code><br>setTimeout就是发起函数、callback就是回调函数。</li></ul></li></ul></li></ul><p>如： <code>异步的Ajax</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new new XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = callback; //callback为回调函数</span><br><span class="line">xhr.open(&apos;get&apos;,url,true);</span><br><span class="line">xhr.send(null); // send为发起函数</span><br></pre></td></tr></table></figure></p><p>可以看出发起函数和回调函数也可以是分离的。</p><p>既然同步任务是在主线程中执行的，那么异步任务何时执行？<br>答：是这样的，一旦栈中同步任务执行完毕后，系统就会通过 事件循环 机制读取任务队列中的任务一个个移<br>到栈中去执行。</p><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>当主线程中的任务执行完毕后，会从任务队列中获取任务一个个的放在栈中执行去执行，这个过程是循环不断的，<br>所以整个的这种运行机制又称为事件循环。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>在js中，代码最终都是在栈中执行的，栈结构的特点是：<strong>先进后出，后进先出</strong>。<br>我们来看下面代码的运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function bar()&#123;</span><br><span class="line">console.log(1);</span><br><span class="line">foo();</span><br><span class="line">&#125;</span><br><span class="line">function foo()&#123;</span><br><span class="line">par();</span><br><span class="line">console.log(3);</span><br><span class="line">&#125;</span><br><span class="line">function par()&#123;</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">console.log(2);</span><br><span class="line">&#125;,0);</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure></p><p>运行的最终结果是：132。 为什么结果不是123呢？<br>下我们来分析下代码运行时入栈和出栈的过程。</p><p>首先当调用函数 bar() 时，此函数就会先入栈，其内部的 console.log(1) 也会随之入栈执行。<br><img src="/2019/05/16/JavaScript运行机制/1.png" alt="1"><br>执行完console.log(1)后，就要出栈，于是控制台先打印出结果1，只剩下bar()在栈中。接着再执行函数bar内部的<br>函数foo，于是函数foo也开心的入栈了。<br><img src="/2019/05/16/JavaScript运行机制/2.png" alt="2"><br>执行函数foo的内部代码，调用函数 par() ，于是函数par()也要跟着入栈。<br><img src="/2019/05/16/JavaScript运行机制/3.png" alt="3"><br>由于函数par()内部执行遇到了 异步函数setTimeout ,异步函数则会由浏览器的Runtime运行环境的工作线程来处<br>理，等定时器设置的时间到达就会被放到任务队列中，此时栈的同步任务继续执行。<br><img src="/2019/05/16/JavaScript运行机制/gz.png" alt="gz"><br>接着在执行par函数中的 console.log(3) ,控制台打印结果为3 ,此时栈的代码执行完毕后，会按照栈的特点进行<br><strong>先进后出，后进先出</strong>顺序进行 出栈 。出栈顺序：<strong>先函数par()—-》后函数foo()</strong>—-》<strong>最后函数bar</strong>.</p><p>最后只剩下异步任务，由主线程去获取任务队列中的任务放在栈中去执行。也可以认为栈中的同步代码执行总是在<br>读取 异步任务 之前执行。<br><img src="/2019/05/16/JavaScript运行机制/5.png" alt="5"><br>最后执行setTimeout中的回调函数：结果控制台输出为2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">console.log(2);</span><br><span class="line">&#125;,0);</span><br></pre></td></tr></table></figure></p><p>所以最终代码的运行结果为132。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>js引擎是单线程执行js代码，同步任务在栈中按顺序执行，如果某一个同步任务没有执行完毕，则后面的代码<br>将会处于阻塞等待状态</li><li>栈中若执行遇到了异步任务（如定时器、异步Ajax、事件），会将此异步任务通过浏览器对应的工作线程来<br>处理。</li><li>工作线程中的所有异步任务均会按照设定的时间进行等待，时间一到会被加入任务队列。如果是异步ajax,则<br>等待其返回结果在加入到任务队列</li><li>当栈中为空时，会通过事件循环来一个个获取任务队列中的任务放到栈中进行逐个运行。即栈中的同步任务<br>总是在读取 异步任务 之前执行</li><li>定时器设置的时间不一定按照设定的时间进行执行，这得取决于栈中同步任务耗费的时间。因为栈中执行的<br>同步任务如果耗费很长时间，则会影响到异步任务回调函数的执行。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;你真懂JavaScript运行机制吗1？&quot;&gt;&lt;a href=&quot;#你真懂JavaScript运行机制吗1？&quot; class=&quot;headerlink&quot; title=&quot;你真懂JavaScript运行机制吗1？&quot;&gt;&lt;/a&gt;你真懂JavaScript运行机制吗1？&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
</feed>
