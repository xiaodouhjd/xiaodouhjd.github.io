<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小豆的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-15T09:37:22.841Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jindou Hou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue反向代理</title>
    <link href="http://yoursite.com/2019/06/15/vue%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/06/15/vue反向代理/</id>
    <published>2019-06-15T09:36:39.000Z</published>
    <updated>2019-06-15T09:37:22.841Z</updated>
    
    <content type="html"><![CDATA[<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>A - C - B</p><p>前端代码的访问地址 - <a href="http://118.89.203.190/maizuo" target="_blank" rel="noopener">http://118.89.203.190/maizuo</a><br>后端接口的方位地址 - <a href="http://118.89.203.190:8080" target="_blank" rel="noopener">http://118.89.203.190:8080</a></p><p>同一台服务器 使用反向代理（nginx) </p><p><a href="http://118.89.203.190/maizuo" target="_blank" rel="noopener">http://118.89.203.190/maizuo</a> -&gt; <a href="http://118.89.203.190" target="_blank" rel="noopener">http://118.89.203.190</a> -&gt; <a href="http://118.89.203.190:8080" target="_blank" rel="noopener">http://118.89.203.190:8080</a></p><h3 id="目前我们的vue项目的情况"><a href="#目前我们的vue项目的情况" class="headerlink" title="目前我们的vue项目的情况"></a>目前我们的vue项目的情况</h3><p><a href="http://118.89.203.190/maizuo" target="_blank" rel="noopener">http://118.89.203.190/maizuo</a> -&gt;<br><a href="http://118.89.203.190/mg/lovev/miguMovie/data/seeFilmData.jsp" target="_blank" rel="noopener">http://118.89.203.190/mg/lovev/miguMovie/data/seeFilmData.jsp</a> -&gt;<br>D <a href="http://118.89.203.190:9090/mg/lovev/miguMovie/data/seeFilmData.jsp" target="_blank" rel="noopener">http://118.89.203.190:9090/mg/lovev/miguMovie/data/seeFilmData.jsp</a> -&gt;<br><a href="http://movie.miguvideo.com/lovev/miguMovie/data/seeFilmData.jsp" target="_blank" rel="noopener">http://movie.miguvideo.com/lovev/miguMovie/data/seeFilmData.jsp</a></p><p>? C - B 需要使用nginx反向代理，但是 c - B是不同的两个服务器的服务，nginx是没办法直接去代理的, 它只能是，把同一台服务器上的 80的服务代理到其他的端口服务 （80 -&gt; 9090）</p><p>这时，我们需要在自己的服务器上启动一个 9090 的nodejs服务</p><ol><li>安装 nodejs </li><li><p>启动一个后台的服务，服务监听的端口是 9090 （express）<br> 2.0 在 你自己的电脑上吧 express 项目写好<br> 创建一个server.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const proxy = require(&apos;http-proxy-middleware&apos;);</span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&apos;hello world, 我是一个nodejs服务&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// http://118.89.203.190:9090/mg/lovev/miguMovie/data/seeFilmData.jsp -&gt; http://movie.miguvideo.com/lovev/miguMovie/data/seeFilmData.jsp</span><br><span class="line">app.use(&apos;/mg&apos;, proxy(&#123;</span><br><span class="line">  target: &apos;http://movie.miguvideo.com&apos;,</span><br><span class="line">  changeOrigin: true, // 主动修改 请求头的 origin ，以防止有些服务对它的限制</span><br><span class="line">  pathRewrite: &#123;</span><br><span class="line">    &apos;^/mg&apos;: &apos;&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.listen(9090)</span><br></pre></td></tr></table></figure></li><li><p>express 这个项目，要将 9090 的地址转发到真实的服务器上，需要使用 http-proxy-middleware 这个模块<br> 3.1 npm install –save http-proxy-middleware<br> 3.2 对 9090 上某个请求做转发</p></li><li>express 这个项目代理配置成功之后，将 node_models 给删除掉再上传到服务器的 /root 目录下</li><li>到 服务的 这个express 项目 npm install 。然后启动它<br> 5.1 为了让 这个后台项目长久运行正常，我们需要守护他的进程<br> 5.2 npm install -g pm2</li><li>接下来，完成 80 -&gt; 9090 服务的反向代理处理<br> 6.1 找到 nginx 配置文件所在的路径  /etc/nginx/conf.d/default.conf<br> 6.2 先不要着急去修改这个文件，可以先备份一下。(确保，你已经在 /etc/nginx/conf.d)<pre><code>cp default.conf default.conf.bak</code></pre> 6.3 去修改 default.conf (推荐吧这个文件传到本地电脑上来改，改完之后再上传回去)<br> 6.4 测试 nginx 配置文件是否有明确的问题  <code>nginx -t</code><br> 6.5 重启 nginx   <code>nginx -s reload</code><br> 6.6 测试</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;反向代理&quot;&gt;&lt;a href=&quot;#反向代理&quot; class=&quot;headerlink&quot; title=&quot;反向代理&quot;&gt;&lt;/a&gt;反向代理&lt;/h3&gt;&lt;p&gt;A - C - B&lt;/p&gt;
&lt;p&gt;前端代码的访问地址 - &lt;a href=&quot;http://118.89.203.190/ma
      
    
    </summary>
    
    
      <category term="vue反向代理" scheme="http://yoursite.com/tags/vue%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>vue正向代理</title>
    <link href="http://yoursite.com/2019/06/15/vue%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/06/15/vue正向代理/</id>
    <published>2019-06-15T09:35:27.000Z</published>
    <updated>2019-06-15T09:37:26.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="16-2正向代理"><a href="#16-2正向代理" class="headerlink" title="16-2正向代理"></a>16-2正向代理</h2><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ol><li>只会产生在浏览器上。</li><li>域名，端口，协议三者有一个不同，就会跨域</li><li>如果是后台代码，向别人的网站偷数据，是不会有跨域问题的。</li></ol><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>1.0.0.1  -&gt; <a href="http://www.facebook.com" target="_blank" rel="noopener">www.facebook.com</a></p><p>1.0.0.1  -&gt; 128.28.28.28 -&gt; <a href="http://www.facebook.com" target="_blank" rel="noopener">www.facebook.com</a></p><p>localhost:8080 -&gt; m.maoyan.com    跨域</p><p>localhost:8080 -&gt; localhost:8080/后台服务 -&gt; m.maoyan.com</p><h3 id="1-在文件夹根目录下创建一个vue-comfig-js"><a href="#1-在文件夹根目录下创建一个vue-comfig-js" class="headerlink" title="1.在文件夹根目录下创建一个vue.comfig.js"></a>1.在文件夹根目录下创建一个vue.comfig.js</h3><h5 id="vue-cli3-0-需要自己去手动添加vue-config-js文件"><a href="#vue-cli3-0-需要自己去手动添加vue-config-js文件" class="headerlink" title="vue-cli3.0 需要自己去手动添加vue.config.js文件"></a>vue-cli3.0 需要自己去手动添加vue.config.js文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 配置文件</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // 选项</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    // port: 9090</span><br><span class="line">    // 正向代理的配置</span><br><span class="line">    // http://localhost:8080/api/find =&gt; http://m.maoyan.com/api/find</span><br><span class="line">    // proxy: &apos;http://i.waimai.meituan.com/&apos;</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      // key - 请求前缀</span><br><span class="line">      // value - 代理选项设置</span><br><span class="line">      // http://localhost:8080/maoyan/api/find =&gt; http://m.maoyan.com/api/find</span><br><span class="line">      &apos;/maoyan&apos;: &#123;</span><br><span class="line">        target: &apos;http://m.maoyan.com/&apos;,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &apos;^/maoyan&apos;: &apos;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &apos;/meituan&apos;: &#123;</span><br><span class="line">        target: &apos;http://i.waimai.meituan.com/&apos;,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &apos;^/meituan&apos;: &apos;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &apos;/mg&apos;: &#123;</span><br><span class="line">        target: &apos;http://movie.miguvideo.com/&apos;,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &apos;^/mg&apos;: &apos;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2请求直接改成本地网络就OK了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//http://localhost:8080</span><br><span class="line"> axios.get(&apos;http://localhost:8080/maoyan/ajax/cinemaList&apos;)</span><br><span class="line">        .then(response =&gt; &#123;</span><br><span class="line">          let res = response.data</span><br><span class="line">          console.log(res)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><hr><h3 id="正向代理的一些问题"><a href="#正向代理的一些问题" class="headerlink" title="正向代理的一些问题"></a>正向代理的一些问题</h3><ol><li>只能用在开发阶段</li><li>上线阶段，如果前端代码与后台代码是同一个服务，那么不涉及跨域问题，那么就不要正向代理。<pre><code>如果前端代码与后台代码不是同一个服务。这个时候是借助nginx的代理配置来代理请求。如果跨域，可以配置 nginx 的反向代理。</code></pre></li></ol><h3 id="axios-post请求参数问题"><a href="#axios-post请求参数问题" class="headerlink" title="axios - post请求参数问题"></a>axios - post请求参数问题</h3><blockquote><p>很多时候，你会发现，我们用 axios 发生 post 请求，后台告诉你，接收不到你传递过来的参数</p></blockquote><ol><li>让后台改</li><li>前端自己改</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;16-2正向代理&quot;&gt;&lt;a href=&quot;#16-2正向代理&quot; class=&quot;headerlink&quot; title=&quot;16-2正向代理&quot;&gt;&lt;/a&gt;16-2正向代理&lt;/h2&gt;&lt;h3 id=&quot;跨域&quot;&gt;&lt;a href=&quot;#跨域&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="正向代理" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>vue脚手架</title>
    <link href="http://yoursite.com/2019/06/15/vue%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>http://yoursite.com/2019/06/15/vue脚手架/</id>
    <published>2019-06-15T09:33:54.000Z</published>
    <updated>2019-06-15T09:34:32.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue脚手架"><a href="#vue脚手架" class="headerlink" title="vue脚手架"></a>vue脚手架</h1><p><a href="https://cli.vuejs.org/zh/" target="_blank" rel="noopener">vue脚手架官网</a></p><h5 id="首先安装脚手架"><a href="#首先安装脚手架" class="headerlink" title="首先安装脚手架:"></a>首先安装脚手架:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line">OR</span><br><span class="line">yarn global add @vue/cli</span><br></pre></td></tr></table></figure><h5 id="这个命令来检查其版本是否正确"><a href="#这个命令来检查其版本是否正确" class="headerlink" title="这个命令来检查其版本是否正确:"></a>这个命令来检查其版本是否正确:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue --version</span><br></pre></td></tr></table></figure><h5 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create hello-world</span><br></pre></td></tr></table></figure><p>最后把自己所需的选项选好，命名就创建完成了</p><h5 id="使用图形化界面"><a href="#使用图形化界面" class="headerlink" title="使用图形化界面"></a>使用图形化界面</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure><p><img src="en-resource://database/799:1" alt="b445678f1a79c36cb74b54971e2959f9.png"></p><h5 id="开发时"><a href="#开发时" class="headerlink" title="开发时"></a>开发时</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure><h5 id="生产上线时"><a href="#生产上线时" class="headerlink" title="生产上线时"></a>生产上线时</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run test</span><br></pre></td></tr></table></figure><h5 id="运行-eslint-的检查，并且会自动修复一些-eslint-的错误"><a href="#运行-eslint-的检查，并且会自动修复一些-eslint-的错误" class="headerlink" title="运行 eslint 的检查，并且会自动修复一些 eslint 的错误"></a>运行 eslint 的检查，并且会自动修复一些 eslint 的错误</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run lint</span><br></pre></td></tr></table></figure><h1 id="项目的目录结构"><a href="#项目的目录结构" class="headerlink" title="项目的目录结构"></a>项目的目录结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- public      静态资源文件夹，它里面的内容是不需要 webpack 做打包构建的内容。</span><br><span class="line">  - favicon.ico</span><br><span class="line">  - index.html        用于 webpack 主动生成 index.html 的模板</span><br><span class="line">- src         项目源文件夹，你写代码的位置。这个里面的所有内容，都会经过webpack的打包构建</span><br><span class="line">  - assets    静态资源文件夹，这个里面主要放 css img font 之类的东西，</span><br><span class="line">  - components  vue的组件</span><br><span class="line">  - App.vue     老二组件</span><br><span class="line">  - main.js     项目的入口js文件</span><br><span class="line">- .browserslistrc   浏览器的兼容配置文件，它主要是给到 postcss 使用的。</span><br><span class="line">- .editorconfig     告诉我们编辑器的配置</span><br><span class="line">- .eslintrc.js      eslint 的规则配置文件</span><br><span class="line">- .gitignore        git 忽略文件</span><br><span class="line">- babel.config.js   babel 的配置，.babelrc</span><br><span class="line">- package-lock.json npm 锁文件</span><br><span class="line">- package.json      npm 依赖项，与当前项目的描述</span><br><span class="line">- postcss.config.js postcss 的配置文件</span><br><span class="line">- README.md         读我文件</span><br></pre></td></tr></table></figure><h3 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h3><h3 id="假数据"><a href="#假数据" class="headerlink" title="假数据 -"></a>假数据 -</h3><h3 id="1-自己写json文件"><a href="#1-自己写json文件" class="headerlink" title="1. 自己写json文件"></a>1. 自己写json文件</h3><blockquote><p>假数据应该放到 public 文件夹下</p></blockquote><p>todos.json</p><h3 id="2-mockjs"><a href="#2-mockjs" class="headerlink" title="2. mockjs"></a>2. mockjs</h3><blockquote><p>一款能够创建假数据，并且这个假数据还有些真实的工具。它主要是拦截我们的ajax请求来实现。</p></blockquote><ol><li><p>安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save mockjs</span><br></pre></td></tr></table></figure></li><li><p>去编写 mockjs 的拦截代码 src/mockdata/index.js</p></li><li>在 main.js 中，引入第2步中的文件</li></ol><h3 id="json-server"><a href="#json-server" class="headerlink" title="json-server"></a>json-server</h3><blockquote><p>前端开发，很多时候，我们前端的页面已经做好了，下一步就是要跟后台做接口的联调，但是这个时候后台可能还没有写完。这个时候就需要我们自己来造假数据，好使前端的业务逻辑能够跑起来。<br>使用  json-server 来模拟假数据</p></blockquote><p>todo.json</p><p>{<br>  data: [<br>    { name: ‘吃饭’, id: 1 },<br>    { name: ‘睡觉’, id: 2 }<br>  ]<br>}</p><p>{<br>  data: [<br>    { aname: ‘吃饭’, aid: 1 },<br>    { aname: ‘睡觉’, aid: 2 }<br>  ]<br>}<br><a href="https://www.npmjs.com" target="_blank" rel="noopener">json-server官网</a><br><strong>入门</strong><br><strong>前端人员开发必备</strong></p><h5 id="安装JSON服务器"><a href="#安装JSON服务器" class="headerlink" title="安装JSON服务器"></a>安装JSON服务器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g json-server</span><br></pre></td></tr></table></figure><h5 id="创建db-json包含一些数据的文件"><a href="#创建db-json包含一些数据的文件" class="headerlink" title="创建db.json包含一些数据的文件"></a>创建db.json包含一些数据的文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;posts&quot;: [</span><br><span class="line">    &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;comments&quot;: [</span><br><span class="line">    &#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启动JSON服务器"><a href="#启动JSON服务器" class="headerlink" title="启动JSON服务器"></a>启动JSON服务器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json-server --watch db.json</span><br></pre></td></tr></table></figure><h5 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h5><p>根据以前的db.json文件，这里是所有默认路由。您还可以使用添加其他路线–routes。<br><strong>多条路线</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET    /posts</span><br><span class="line">GET    /posts/1</span><br><span class="line">POST   /posts</span><br><span class="line">PUT    /posts/1</span><br><span class="line">PATCH  /posts/1</span><br><span class="line">DELETE /posts/1</span><br></pre></td></tr></table></figure></p><h3 id="最后封装axios"><a href="#最后封装axios" class="headerlink" title="最后封装axios"></a>最后封装axios</h3><ol><li>在 src 下面 新建一个文件  src/utils/http.js</li><li>在 http.js 中做封装，并且暴露出去</li><li>在 main.js 将 2 中的东西给添加到 vue 的原型上面。后续可以使用 this.$http 来使用</li></ol><p>// 1. 引入 axios<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;;</span><br></pre></td></tr></table></figure></p><p>// 2. 生成一个 axios 的实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const http = axios.create();</span><br></pre></td></tr></table></figure></p><p>// 3. 设置 http 的一些默认选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.defaults.baseURL = process.env.NODE_ENV === &apos;production&apos; ? &apos;http://www.baidu.com/&apos; : &apos;http://localhost:3000/&apos;; // 基准url地址</span><br><span class="line">http.defaults.timeout = 10000; // 超过这个时间点请求还没有完成，那么就报错。</span><br></pre></td></tr></table></figure></p><p>// 4. 做请求的拦截</p><p>// 5. 做响应的拦截<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.interceptors.response.use(response =&gt; &#123;</span><br><span class="line">  return response.data;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>// 6. 不要忘了暴露<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default http;</span><br></pre></td></tr></table></figure></p><p>// http.get()<br>// http.post()<br>// http.delete()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vue脚手架&quot;&gt;&lt;a href=&quot;#vue脚手架&quot; class=&quot;headerlink&quot; title=&quot;vue脚手架&quot;&gt;&lt;/a&gt;vue脚手架&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://cli.vuejs.org/zh/&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="vue-cli" scheme="http://yoursite.com/tags/vue-cli/"/>
    
  </entry>
  
  <entry>
    <title>vue-router</title>
    <link href="http://yoursite.com/2019/06/15/vue-router/"/>
    <id>http://yoursite.com/2019/06/15/vue-router/</id>
    <published>2019-06-15T09:32:25.000Z</published>
    <updated>2019-06-15T09:33:09.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端路由-vue-router"><a href="#前端路由-vue-router" class="headerlink" title="前端路由 vue-router"></a>前端路由 vue-router</h1><h5 id="两种应用"><a href="#两种应用" class="headerlink" title="两种应用"></a>两种应用</h5><ul><li><p>单页面应用（SPA）single-page-application</p></li><li><p>多页面应用（MPA）一个项目中有多个html文件的。</p></li></ul><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><ol><li><p>安装vue-router </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save vue-router</span><br></pre></td></tr></table></figure></li><li><p>项目中选择某个位置放入一个坑 router-view 这个组件</p></li><li>项目中配置路由规则，最后要暴露出去路由器的实例对象</li><li>在main.js中也就是 new Vue 的地方需要将第3步中暴露出来的 router 实例对象配置给 根组件 的 router 选项</li></ol><h5 id="router的使用"><a href="#router的使用" class="headerlink" title="router的使用"></a>router的使用</h5><ol start="0"><li><p>引入 vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br></pre></td></tr></table></figure></li><li><p>引入 vue-router</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import VueRouter from &apos;vue-router&apos;</span><br></pre></td></tr></table></figure></li></ol><p>1.1 引入路由页面级别组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Home from &apos;../views/Home.vue&apos;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>使用 VueRouter 插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure></li><li><p>配置路由规则 [{}, {}, {}]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/home&apos;,</span><br><span class="line">    component: Home,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        // /home/page1</span><br><span class="line">        path: &apos;page1&apos;,</span><br><span class="line">        name: &apos;page1&apos;,</span><br><span class="line">        component: Page1</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        // /home/page2</span><br><span class="line">        path: &apos;page2&apos;,</span><br><span class="line">        name: &apos;page2&apos;,</span><br><span class="line">        component: Page2</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure></li><li><p>实例化路由器对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>将第4步中的东西给暴露出去</p><h3 id="router-view标签-坑"><a href="#router-view标签-坑" class="headerlink" title="router-view标签(坑)"></a>router-view标签(坑)</h3></li></ol><h3 id="router-link标签"><a href="#router-link标签" class="headerlink" title="router-link标签"></a>router-link标签</h3><blockquote><p>这也是使用了 路由之后，提供给我们的一个全局组件，它就是一个 a 标签，能帮我们实现路由的切换<br>他还有个replace属性</p></blockquote><ul><li>to 功能与href相似</li><li>active-class  能够让我们修改默认高亮的类的名字 默认值是 ‘router-link-active’</li></ul><h3 id="router-link-与-a-标签的区别"><a href="#router-link-与-a-标签的区别" class="headerlink" title="router-link 与 a 标签的区别"></a>router-link 与 a 标签的区别</h3><ol><li>默认情况下，写不写 # 的问题</li><li>router-link 可以帮我们实现高亮的效果</li></ol><h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h3><p>当我们使用上路由之后，会在 Vue 的原型上挂载 两个属性</p><ul><li>$route    当前匹配的路由对象信息</li><li>$router   路由器的实例对象</li></ul><h3 id="编程式导航-通过js代码来控制路由的跳转"><a href="#编程式导航-通过js代码来控制路由的跳转" class="headerlink" title="编程式导航 - 通过js代码来控制路由的跳转"></a>编程式导航 - 通过js代码来控制路由的跳转</h3><p>$router.push()    跳转页面，新增一个历史记录</p><p>$router.back()    后退</p><p>$router.forward() 前进</p><p>$router.go()      根据参数来看是前进还是后退</p><p>$router.replace() 重定向页面，不加历史记录  </p><h3 id="命令路由"><a href="#命令路由" class="headerlink" title="命令路由"></a>命令路由</h3><blockquote><p>在路由规则上给每个规则加上name属性，后续方便我们操作路由的跳转<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/home/page1&quot;&gt;&lt;/router-link&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123; path: &apos;/home/page1&apos;, name: &apos;page1&apos;, query: &#123;&#125;, params: &#123;&#125; &#125;&quot;&gt;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>to属性传对象的时候，可以有如果属性</p><ul><li>path    路由路径</li><li>name    命名路由的名字</li><li>query   search参数</li><li>params  动态路由匹配参数</li></ul><p><strong>PS: params 与 path 不能共存，如果你要传递 params，那么不要使用 path</strong></p><h3 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h3><p> (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar (侧导航) 和 main (主内容) 两个视图，这个时候命名视图就派上用场了。<br>如果 router-view 没有设置名字，那么默认为 default。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></p><p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components配置 (带上 s)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      components: &#123;</span><br><span class="line">        default: Foo,</span><br><span class="line">        a: Bar,</span><br><span class="line">        b: Baz</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h3><p>redirect重定向<br>“重定向”的意思是，当用户访问 /a时，URL 将会被替换成 /b，然后匹配路由为 /b<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &apos;*&apos;, redirect: &apos;/b&apos; &#125;</span><br><span class="line">  ]&#125;)</span><br></pre></td></tr></table></figure></p><p>重定向的目标也可以是一个命名的路由：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &apos;/a&apos;, redirect: &#123; name: &apos;foo&apos; &#125;&#125;</span><br><span class="line">  ]&#125;)</span><br></pre></td></tr></table></figure></p><p>甚至是一个方法，动态返回重定向目标：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &apos;/a&apos;, redirect: to =&gt; &#123;</span><br><span class="line">      // 方法接收 目标路由 作为参数</span><br><span class="line">      // return 重定向的 字符串路径/路径对象</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  ]&#125;)</span><br></pre></td></tr></table></figure></p><h5 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h5><p>“别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &apos;/a&apos;, component: A, alias: &apos;/b&apos; &#125;</span><br><span class="line">  ]&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a>路由组件传参</h3><p>在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。</p><p>使用 props 将组件和路由解耦：<br><strong>取代与 $route 的耦合</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&apos;&#125;const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &apos;/user/:id&apos;, component: User &#125;</span><br><span class="line">  ]&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>通过 props 解耦</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  props: [&apos;id&apos;],</span><br><span class="line">  template: &apos;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&apos;&#125;const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &apos;/user/:id&apos;, component: User, props: true &#125;,</span><br><span class="line"></span><br><span class="line">    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/user/:id&apos;,</span><br><span class="line">      components: &#123; default: User, sidebar: Sidebar &#125;,</span><br><span class="line">      props: &#123; default: true, sidebar: false &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="布尔模式"><a href="#布尔模式" class="headerlink" title="布尔模式"></a>布尔模式</h4><p>如果 props 被设置为 true，route.params 将会被设置为组件属性。</p><h4 id="对象模式"><a href="#对象模式" class="headerlink" title="对象模式"></a>对象模式</h4><p>如果 props 是一个对象，它会被按原样设置为组件属性。当 props 是静态的时候有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &apos;/promotion/from-newsletter&apos;, component: Promotion, props: &#123; newsletterPopup: false &#125; &#125;</span><br><span class="line">  ]&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="函数模式"><a href="#函数模式" class="headerlink" title="函数模式"></a>函数模式</h4><p>你可以创建一个函数返回 props。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &apos;/search&apos;, component: SearchUser, props: (route) =&gt; (&#123; query: route.query.q &#125;) &#125;</span><br><span class="line">  ]&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="vue路由的两种模式"><a href="#vue路由的两种模式" class="headerlink" title="vue路由的两种模式"></a>vue路由的两种模式</h3><ul><li>hash      (默认)</li><li>history</li></ul><p>要修改当前路由模式可以在 实例化 路由器对象的时候设置 mode 选项<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="这两种模式的区别"><a href="#这两种模式的区别" class="headerlink" title="这两种模式的区别"></a>这两种模式的区别</h4><ol><li>从外观上来说，hash模式会在url地址上面有一个 # 号，而 history 没有，更像url地址。</li><li>从原理上来说，hash模式是通过 window.onHashChagne 这个事件来处理的。而 history 模式是基于 html5 中 history 新增的一些api. hisotry.pushState() history.replaceState() window.onpopstate 来实现的</li><li>hisotry模式还需要后台配置去处理上线的404的问题</li></ol><h3 id="nprogress"><a href="#nprogress" class="headerlink" title="nprogress"></a>nprogress</h3><p><a href="https://github.com/rstacruz/nprogress" target="_blank" rel="noopener">更多用法</a><br>适用于Ajax’y应用程序的超薄进度条。受Google，YouTube和Medium的启发。</p><p>将nprogress.js和nprogress.css添加到项目中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&apos;nprogress.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">&lt;link rel=&apos;stylesheet&apos; href=&apos;nprogress.css&apos;/&gt;</span><br></pre></td></tr></table></figure></p><p>NProgress可通过bower和npm获得。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save nprogress</span><br></pre></td></tr></table></figure></p><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>只需致电start()并done()控制进度条即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NProgress.start（）;</span><br><span class="line">NProgress.done();</span><br></pre></td></tr></table></figure></p><h2 id="vue-导航守卫"><a href="#vue-导航守卫" class="headerlink" title="vue 导航守卫"></a>vue 导航守卫</h2><p>主要分为三个大块</p><ul><li>全局<ul><li>全局前置  beforeEach</li><li>全局解析守卫 beforeResolve</li><li>全局后置  afterEach</li></ul></li><li>路由独享的<ul><li>beforeEnter     进入当前路由时</li></ul></li><li>组件级别的<ul><li>beforeRouteEnter    进入当前组件时</li><li>beforeRouteUpdate   当前组件更新时</li><li>beforeRouteLeave    退出当前组件时</li></ul></li></ul><h5 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h5><ul><li>接收一个函数，函数中有三个参数：</li><li>to        -  要去的路由</li><li>from      -  来自哪个路由</li><li>next      -  是一个方法，要不要他去</li><li>next</li><li><ol><li>如果直接调用，那么就相当于放行</li></ol></li><li><ol start="2"><li>如果调用，但是传递了一个 false, 那么就不放行</li></ol></li><li><ol start="3"><li>如果不调用，也不放行。</li></ol></li><li><ol start="4"><li>调用，并且里面可以传递路由的path路径或者是路由的对象信息。那么就可以重定向到我们的参数中所指定的位置。</li></ol><h5 id="全局后置守卫，"><a href="#全局后置守卫，" class="headerlink" title="全局后置守卫，"></a>全局后置守卫，</h5><p>后置守卫没有 next</p><h3 id="导航守卫的钩子函数"><a href="#导航守卫的钩子函数" class="headerlink" title="导航守卫的钩子函数"></a>导航守卫的钩子函数</h3></li></ul><blockquote><p>在路由发生变化的时候会主动触发的一些函数</p></blockquote><h3 id="作用场景"><a href="#作用场景" class="headerlink" title="作用场景"></a>作用场景</h3><ol><li>beforeEach 与 afterEach 能实现页面进度条的效果</li><li>登录拦截<ol><li>先排除 组件级别</li><li>afterEach 排除</li><li>正常情况下，如果是后台管理系统的话，因为处理登录与注册页面之外其他的都需要做登录的拦截，那么就可以再 全局前置 里面去做。如果项目中只有那么一个到两个需要做拦截的页面，那么就可以再他们自己的路由独享里面去做。</li></ol></li></ol><h3 id="判断是否登录例子"><a href="#判断是否登录例子" class="headerlink" title="判断是否登录例子"></a>判断是否登录例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  NProgress.start()</span><br><span class="line"></span><br><span class="line">  // 路由拦截</span><br><span class="line">  if (to.meta.requireLogin) &#123;</span><br><span class="line">    // 判断是否有登录</span><br><span class="line">    if (window.localStorage.getItem(&apos;userInfo&apos;)) &#123;</span><br><span class="line">      // 有登录</span><br><span class="line">      next()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 没有登录</span><br><span class="line">      // next(&apos;/login&apos;)</span><br><span class="line">      console.log(to)</span><br><span class="line">      next(&#123;</span><br><span class="line">        path: &apos;/login&apos;,</span><br><span class="line">        query: &#123;</span><br><span class="line">          redirect: to.fullPath</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h3><p>定义路由的时候可以配置 meta 字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/foo&apos;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: &apos;bar&apos;,</span><br><span class="line">          component: Bar,</span><br><span class="line">          // a meta field</span><br><span class="line">          meta: &#123; requiresAuth: true &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]&#125;)</span><br></pre></td></tr></table></figure></p><p>我们称呼 routes 配置中的每个路由对象为 路由记录。路由记录可以是嵌套的，因此，当一个路由匹配成功后，他可能匹配多个路由记录<br>例如，根据上面的路由配置，/foo/bar 这个 URL 将会匹配父路由记录以及子路由记录。<br>一个路由匹配到的所有路由记录会暴露为 $route 对象 (还有在导航守卫中的路由对象) 的 $route.matched 数组。因此，我们需要遍历 $route.matched 来检查路由记录中的 meta 字段。<br>下面例子展示在全局导航守卫中检查元字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123;</span><br><span class="line">    // this route requires auth, check if logged in</span><br><span class="line">    // if not, redirect to login page.</span><br><span class="line">    if (!auth.loggedIn()) &#123;</span><br><span class="line">      next(&#123;</span><br><span class="line">        path: &apos;/login&apos;,</span><br><span class="line">        query: &#123; redirect: to.fullPath &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next() // 确保一定要调用 next()</span><br><span class="line">  &#125;&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端路由-vue-router&quot;&gt;&lt;a href=&quot;#前端路由-vue-router&quot; class=&quot;headerlink&quot; title=&quot;前端路由 vue-router&quot;&gt;&lt;/a&gt;前端路由 vue-router&lt;/h1&gt;&lt;h5 id=&quot;两种应用&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="vue-router" scheme="http://yoursite.com/tags/vue-router/"/>
    
  </entry>
  
  <entry>
    <title>vuex总结</title>
    <link href="http://yoursite.com/2019/06/15/vuex%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/06/15/vuex总结/</id>
    <published>2019-06-15T09:29:09.000Z</published>
    <updated>2019-06-15T09:41:32.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><h3 id="什么时候需要使用-vuex"><a href="#什么时候需要使用-vuex" class="headerlink" title="什么时候需要使用 vuex"></a>什么时候需要使用 vuex</h3><ol><li>当你不知道该不该用的时候，那就是不该用。（你自会知道什么时候需要用到它）</li><li>组件之间通信很复杂的情况下</li><li>项目中使用了路由，并且路由页面组件中需要通信的时候，</li><li>项目写着写着头发一大把掉的时候。</li></ol><h3 id="vuex的操作流程"><a href="#vuex的操作流程" class="headerlink" title="vuex的操作流程"></a>vuex的操作流程</h3><ol><li>先要有仓库，将我们项目中组件上需要共享的数据放置到我们 仓库中 state 的位置。</li><li>组件要使用 仓库 中 state 的数据，就从仓库里面拿出来用。</li><li>要修改仓库中 state 的数据，<ol><li>commit(提交) mutation</li><li>dispath(派发) action    -&gt; commit mutation</li></ol></li><li>然后仓库中 state 数据发生变化，组件就会得到更新</li></ol><h3 id="vuex-的使用"><a href="#vuex-的使用" class="headerlink" title="vuex 的使用"></a>vuex 的使用</h3><ol><li><p>安装 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vuex `npm install --save vuex`</span><br></pre></td></tr></table></figure></li><li><p>项目中 src/store/index.js 文件中创建仓库的实例对象</p></li><li><p>要 main.js new Vue 的地方配置一个 store 的选项。选项的值就是 2 中 仓库实例对象</p><ol><li><p>引入 vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br></pre></td></tr></table></figure></li><li><p>引入 vuex</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Vuex from &apos;vuex&apos;</span><br></pre></td></tr></table></figure></li><li><p>调用 vuex</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure></li><li><p>创建 仓库的实例对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line"> state: &#123;</span><br><span class="line"> title: &apos;hello-world&apos;</span><br><span class="line">&#125;,</span><br><span class="line">getters: &#123;</span><br><span class="line">// key - getter 的名字</span><br><span class="line"> // value - 值 函数，要有 return</span><br><span class="line"> // key: value</span><br><span class="line">&#125;,</span><br><span class="line">mutations: &#123;</span><br><span class="line"> // key - mutation 的名字</span><br><span class="line"> // value - 函数 接收到 state</span><br><span class="line"> // key: value</span><br><span class="line">&#125;,</span><br><span class="line">actions: &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>暴露 store</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default store;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><h3 id="对象展开运算符"><a href="#对象展开运算符" class="headerlink" title="对象展开运算符"></a>对象展开运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    localComputed () &#123;&#125;,</span><br><span class="line">  ...mapState(&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">也可以使用`...mapState([])`,但前提是映射的计算属性的名称与state的子节点名称相同，如果state在vuex的modules中，则不成功。</span><br></pre></td></tr></table></figure><h3 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a>mapState 辅助函数</h3><p>四种用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState(&#123;</span><br><span class="line">    // 箭头函数可使代码更简练</span><br><span class="line">    count: state =&gt; state.count,</span><br><span class="line"></span><br><span class="line">    // 传字符串参数 &apos;count&apos; 等同于 `state =&gt; state.count`</span><br><span class="line">    countAlias: &apos;count&apos;,</span><br><span class="line"></span><br><span class="line">    // 为了能够使用 `this` 获取局部状态，必须使用常规函数</span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      return state.count + this.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  // 映射 this.count 为 store.state.count</span><br><span class="line">  &apos;count&apos;])</span><br></pre></td></tr></table></figure><h3 id="如何将仓库中的数据拿到组件中去使用"><a href="#如何将仓库中的数据拿到组件中去使用" class="headerlink" title="如何将仓库中的数据拿到组件中去使用"></a>如何将仓库中的数据拿到组件中去使用</h3><p>this.$store 就是仓库的实例对象</p><ol><li>直接使用 this.$store 的方式在组件 template 模板中使用 （不推荐）</li><li><p>组件中使用 计算属性 去拿 仓库的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  title () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.title</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>借助 vuex 提供的辅助函数 mapState<br>mapState([])  - 组件的computed 的 key 必须要跟仓库中 state 里面某个key 相同<br>mapState({})  - 组件的computed 的 key 可以自定义。</p></li><li><p>将 mapState 与 组件自身的 computed 结合 （推荐）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState([<span class="string">'title'</span>]),</span><br><span class="line">  firstName () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name.split(<span class="string">''</span>)[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ol><h2 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h2><p>mapGetters<br>mapGetters将store中的getter映射到局部计算属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapGetters([</span><br><span class="line">    &apos;oneGetter&apos;,</span><br><span class="line">    &apos;anotherGetter&apos;</span><br><span class="line">  ])，</span><br><span class="line">  ...mapGetters(&apos;命名空间的模块名&apos;,[ &apos;oneGetter&apos;, &apos;anotherGetter&apos; ])//第二个获取这个名字的数据</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h2><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。<br>每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。</p><h3 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h3><p>使用mapMutations辅助函数将组件中的methods映射为store.commit调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  // 将this.tips映射成 this.$store.commit(&apos;tips&apos;)</span><br><span class="line">  ...mapMutations([&apos;tips&apos;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="提交载荷（Payload）"><a href="#提交载荷（Payload）" class="headerlink" title="提交载荷（Payload）"></a>提交载荷（Payload）</h3><p>你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//第一个是方法名，第二个是参数</span><br><span class="line">store.commit(&apos;increment&apos;, &#123;</span><br><span class="line">  amount: 10&#125;)</span><br></pre></td></tr></table></figure><p>提交 mutation 的另一种方式是直接使用包含 type 属性的对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&#123;</span><br><span class="line">  type: &apos;increment&apos;,</span><br><span class="line">  amount: 10&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>使用常量替代 Mutation 事件类型,<br>一条重要的原则就是要记住 mutation 必须是同步函数</strong></p><h3 id="如何修改仓库中的数据"><a href="#如何修改仓库中的数据" class="headerlink" title="如何修改仓库中的数据"></a>如何修改仓库中的数据</h3><ol><li>先需要在仓库中定义我们的mutation</li><li>在组件中提交这个mutaion<ol><li>this.$store.commit(‘mutaion的名字’, 要传递的参数)</li><li>this.$store.commit({<br>type: mutaion的名字,<br>其余的参数<br>})</li><li>mapMutations 辅助函数</li></ol></li><li>mutation不允许异步代码的<h2 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h2></li></ol><h3 id="mapAction"><a href="#mapAction" class="headerlink" title="mapAction"></a>mapAction</h3><p>使用mapActions辅助函数将组件的methods映射成store.dispatch调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//第一个是命名空间的名字，模块名，第二个触发的方法名</span><br><span class="line">//当项目只有一个模块时</span><br><span class="line">methods: &#123;</span><br><span class="line">  // 将this.tips映射成 this.$store.dispatch(&apos;tips&apos;)</span><br><span class="line">  ...mapActions(&apos;tips&apos;,[&apos;tips&apos;])</span><br><span class="line">  ...mapActions([&apos;tips&apos;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="如何写异步代码在仓库中-actions"><a href="#如何写异步代码在仓库中-actions" class="headerlink" title="如何写异步代码在仓库中 actions"></a>如何写异步代码在仓库中 actions</h3><ol><li>每一个action里面都可以写异步代码，但是action并不能修改state中的数据，真正修改数据的还是 mutaction</li><li>在组件中如何派发这个action<ol><li>this.$store.dispatch(‘action的名字’)</li><li>mapActions 辅助函数</li></ol></li></ol><h3 id="vuex-分析图："><a href="#vuex-分析图：" class="headerlink" title="vuex 分析图："></a>vuex 分析图：</h3><p><img src="/2019/06/15/vuex总结/1.jpg" alt="1"></p><h3 id="10-命名空间"><a href="#10-命名空间" class="headerlink" title="10-命名空间"></a>10-命名空间</h3><h5 id="为什么推荐大家在做-vuex-moduels-每个模块都加上-命令空间呢"><a href="#为什么推荐大家在做-vuex-moduels-每个模块都加上-命令空间呢" class="headerlink" title="为什么推荐大家在做 vuex moduels 每个模块都加上 命令空间呢"></a>为什么推荐大家在做 vuex moduels 每个模块都加上 命令空间呢</h5><ol><li>操作方便<ol><li>mapState([‘todos’])     根仓库上拿toods</li><li>mapState(‘todo’, [‘todos’])   // this.$store.state.todo.todos</li><li>mapGetters(‘todo’, [‘todos’]) // this.$store.getters.todo.todos</li></ol></li></ol><h4 id="如果-不带命名空间会造成什么影响"><a href="#如果-不带命名空间会造成什么影响" class="headerlink" title="如果 不带命名空间会造成什么影响"></a>如果 不带命名空间会造成什么影响</h4><ol><li>getters 是全局的, 如果在多个模块中有重名的 getter 会报错</li><li>mutations， actions 有重名的话，会都被执行</li></ol><p>最后还有一个看官网</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vuex&quot;&gt;&lt;a href=&quot;#vuex&quot; class=&quot;headerlink&quot; title=&quot;vuex&quot;&gt;&lt;/a&gt;vuex&lt;/h1&gt;&lt;h3 id=&quot;什么时候需要使用-vuex&quot;&gt;&lt;a href=&quot;#什么时候需要使用-vuex&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="vuex" scheme="http://yoursite.com/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>vue基本掌握内容</title>
    <link href="http://yoursite.com/2019/06/02/vue%E5%9F%BA%E6%9C%AC%E6%8E%8C%E6%8F%A1%E5%86%85%E5%AE%B9/"/>
    <id>http://yoursite.com/2019/06/02/vue基本掌握内容/</id>
    <published>2019-06-02T08:24:18.000Z</published>
    <updated>2019-06-02T08:50:30.964Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-数据监测不到更新操作-和-列表渲染的维护状态"><a href="#1-数据监测不到更新操作-和-列表渲染的维护状态" class="headerlink" title="1-数据监测不到更新操作 和 列表渲染的维护状态"></a>1-数据监测不到更新操作 和 列表渲染的维护状态</h3><h4 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">使用一些变异方法或者直接替换数组都能引起页面的更新。</span><br><span class="line"></span><br><span class="line">但是以下两个操作不会：</span><br><span class="line">  1. 直接根据数据下标来修改     vm.list[0] = 9;</span><br><span class="line">  2. 直接修改数据的长度         vm.list.length = 10;</span><br><span class="line"></span><br><span class="line">解决方式：</span><br><span class="line"></span><br><span class="line">  1. 使用 Vue.set 原型方法</span><br><span class="line">  2. 使用 vm.$set 实例方法</span><br><span class="line"></span><br><span class="line">  Vue.set(target, index, value);</span><br><span class="line">  vm.$set(target, index, value);</span><br></pre></td></tr></table></figure><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue 不能检测对象属性的添加或删除：</span><br><span class="line"></span><br><span class="line">Vue.set(target, key, value);</span><br><span class="line">vm.$set(target, key, value);</span><br></pre></td></tr></table></figure><h3 id="列表渲染的维护状态"><a href="#列表渲染的维护状态" class="headerlink" title="列表渲染的维护状态"></a>列表渲染的维护状态</h3><ul><li>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似 Vue 1.x 的 track-by=”$index” 。</li><li>这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。</li><li><p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;item in items&quot; v-bind:key=&quot;item.id&quot;&gt;</span><br><span class="line">  &lt;!-- 内容 --&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</li><li>因为它是 Vue 识别节点的一个通用机制，key 并不与 v-for 特别关联，key 还具有其他用途，我们将在后面的指南中看到其他用途。</li><li>不要使用对象或数组之类的非原始类型值作为 v-for 的 key。用字符串或数类型的值取而代之。</li></ul><h3 id="v-if-与-v-show-的区别："><a href="#v-if-与-v-show-的区别：" class="headerlink" title="v-if 与 v-show 的区别："></a>v-if 与 v-show 的区别：</h3><pre><code>1. 他们都能实现元素的显示隐藏2. v-show只是简单控制元素的display属性（不管条件为真还是为假，这个元素都会被渲染出来），而v-if才是条件渲染（条件为真，元素将会被渲染，条件为假，元素会被销毁）3. v-show有更高的首次渲染开销。v-if的首次渲染开销要小得多。4. v-if有更高的切换开销，v-show切换开销小5. v-if有配套的 v-else-if 和 v-else，而v-show没有6. v-if可以搭配template使用。而v-show不行。</code></pre></li></ul><h3 id="在-元素上使用-v-if-条件渲染分组"><a href="#在-元素上使用-v-if-条件渲染分组" class="headerlink" title="在  元素上使用 v-if 条件渲染分组"></a>在 <template> 元素上使用 v-if 条件渲染分组</template></h3><p>因为 v-if 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 <template> 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 <template> 元素。<br><strong>优点是:不影响内部布局。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;ok&quot;&gt;</span><br><span class="line">  &lt;h1&gt;Title&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 1&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure></template></template></p><h3 id="key-管理复用"><a href="#key-管理复用" class="headerlink" title="key 管理复用"></a>key 管理复用</h3><p><label> 元素仍然会被高效地复用，因为它们没有添加 key 属性。添加key属性就不会复用了。</label></p><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><ul><li>.stop</li><li>.prevent</li><li>.capture</li><li>.self.</li><li>once</li><li>.passive<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 阻止单击事件继续传播 --&gt;</span><br><span class="line">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只有修饰符 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span><br><span class="line">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span><br><span class="line">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span><br><span class="line">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br><span class="line">&lt;!-- self修饰符规定的就是，这个事件只能在绑定事件的元素身上起效果。在他的内部元素身上触发事件是不生效的。。他的原理就是判断  target === currentTarget --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 点击事件将只会触发一次 --&gt;</span><br><span class="line">&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt; </span><br><span class="line">&lt;!-- 而不会等待 `onScroll` 完成 --&gt; </span><br><span class="line">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt; </span><br><span class="line">&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><p>在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span><br><span class="line">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>你可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-on:keyup.page-down=&quot;onPageDown&quot;&gt;</span><br></pre></td></tr></table></figure></p><h3 id="按键码"><a href="#按键码" class="headerlink" title="按键码"></a>按键码</h3><ul><li>.enter</li><li>.tab</li><li>.delete (捕获“删除”和“退格”键)</li><li>.esc</li><li>.space</li><li>.up</li><li>.down</li><li>.left</li><li>.right<br><strong>注意：有一些按键 (.esc 以及所有的方向键) 在 IE9 中有不同的 key 值, 如果你想支持 IE9，这些内置的别名应该是首选。你还可以通过全局 config.keyCodes 对象自定义</strong></li></ul><p>你还可以通过全局 config.keyCodes 对象自定义按键修饰符别名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 可以使用 `v-on:keyup.f1`</span><br><span class="line">Vue.config.keyCodes.f1 = 112</span><br></pre></td></tr></table></figure></p><h3 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h3><p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p><ul><li>.ctrl</li><li>.alt</li><li>.shift</li><li>.meta</li></ul><h4 id="exact-修饰符"><a href="#exact-修饰符" class="headerlink" title="exact 修饰符"></a>exact 修饰符</h4><p>修饰符允许你控制由精确的系统修饰符组合触发的事件</p><h5 id="鼠标按钮修饰符2-2-0-新增"><a href="#鼠标按钮修饰符2-2-0-新增" class="headerlink" title="鼠标按钮修饰符2.2.0 新增"></a>鼠标按钮修饰符2.2.0 新增</h5><ul><li>.left</li><li>.right</li><li>.middle</li></ul><h3 id="v-bind-class"><a href="#v-bind-class" class="headerlink" title="v-bind:class"></a>v-bind:class</h3><ol><li><p>直接使用data的数据，数据是个字符串，这个数据的字符串会直接当做class类名。</p></li><li><p>使用 对象 字面量的事项<br>key: value, key会作为类名，value会转换成boolean类型，如果为真，这个key就会存在，如果为假，这个key就不存在</p></li><li><p>使用 数组的方式</p></li></ol><h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><p>事件绑定的时候，事件处理函数如果没有加括号，那么我们的事件处理函数会自动接收到 event 事件对象</p><p>如果加上括号，那么 event 对象不会自动传递，如果需要，得手动传递，$event</p><h2 id="表单绑定"><a href="#表单绑定" class="headerlink" title="表单绑定"></a>表单绑定</h2><p>你可以用 v-model 指令在表单 input、textarea 及 select 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。<br><strong>注意：v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。</strong><br>v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 value 属性和 input 事件；</li><li>checkbox 和 radio 使用 checked 属性和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul><p><strong>对于需要使用输入法 (如中文、日文、韩文等) 的语言，你会发现 v-model 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用 input 事件。</strong></p><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p><a href="https://cn.vuejs.org/v2/guide/computed.html" target="_blank" rel="noopener">参考</a><br>计算属性，能对现有的data中或者现有的计算属性中的数据做二次处理（计算）。并返回新的数据，这个计算属性可以当做 data 里面的数据一样在页面中或者其他的方法中去使用。<br><strong>但是有一点，计算属性不能直接修改</strong>。。。。<br>他的变化，是基于它的依赖项来的。它的依赖如果发生变化，那么他会重新计算。<br>计算属性vs方法<br> 计算属性有缓存，如果依赖项没有变化，那么相同的计算属性我使用多次，只会在第一次的时候执行。后续都是直接拿的缓存。而方法没有缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123; key, value &#125;</span><br><span class="line">       // key - 计算属性的名字，</span><br><span class="line">       // value - 是一个函数 , 他其实就是  amsg 这个计算属性的 getter</span><br></pre></td></tr></table></figure><h3 id="监听：-watch"><a href="#监听：-watch" class="headerlink" title="监听： watch."></a>监听： watch.</h3><p>监听现有的data或computed中的数据，如果监听的数据有变化，那么监听的回调函数将会被执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123; key,value&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  // key - 要监听的数据</span><br><span class="line">  // value - 监听的回调函数 会接收两个参数，newVal, oldVal</span><br><span class="line">  watch: &#123;</span><br><span class="line">  msg (newVal, oldVal) &#123;</span><br><span class="line">    console.log(&apos;newVal: &apos;, newVal);</span><br><span class="line">    console.log(&apos;oldVal: &apos;, oldVal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin 混入"></a>mixin 混入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> var common = &#123;&#125;</span><br><span class="line">//定义一个对象，这个对象就是包含有vue组件实例相关的选项的一个对象。</span><br><span class="line">/data如果是一个混入对象的选项，那么data需要使用工厂模式</span><br><span class="line">      // 弄成一个方法，方法里面返回对象</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 使用混入</span><br><span class="line">     mixins: [common],</span><br></pre></td></tr></table></figure><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p><a href="https://cn.vuejs.org/v2/guide/components-registration.html" target="_blank" rel="noopener">参考</a><br>使用组件</p><ol><li>创建组件</li><li>全局注册  Vue.component(组件的名字，组件的选项对象)<ol start="2"><li>局部注册  components 选项<h4 id="全局与局部的区别："><a href="#全局与局部的区别：" class="headerlink" title="全局与局部的区别："></a>全局与局部的区别：</h4></li><li>在谁的身上注册的局部组件，就只能用在这个人的身上。</li><li>全局注册的组件可以用在任意位置。必须要在 new Vue 之前去注册。 </li><li>把组件当做一个自定义标签去使用<h4 id="组件的特性"><a href="#组件的特性" class="headerlink" title="组件的特性"></a>组件的特性</h4>这里写法跟 mixin 很像，都是能够使用 new Vue 时传递的哪些选项。<ol><li>el 与 propsData 不能用</li><li>data 必须是一个函数返回对象的形式。</li><li>组件必须要有一个选项是，template 选项，这个选项指定我们组件的内容。</li></ol></li></ol></li></ol><h3 id="组件的一些使用情况："><a href="#组件的一些使用情况：" class="headerlink" title="组件的一些使用情况："></a>组件的一些使用情况：</h3><ol><li>组件的使用，先注册，然后用组件的名字做为标签来使用。</li><li>组件必须要有一个 template 选项，来指定这个组件的模板内容。</li><li>组件的 data 选项 必须是一个函数返回对象的形式。</li><li>组件的命名，可以尽量 短横线方式。<br>也可以使用 驼峰的方式，但是使用的时候需要换成 短横线方式。 （todo）<ul><li><ol><li>使用 x-template 的 script 标签的方式的时候，不需要考虑这条规则</li></ol></li><li><ol start="2"><li>使用 单文件组件， 也不需要考虑这条规则</li></ol></li></ul></li><li>组件的命名不能跟现有的html标签冲突</li><li>组件的 template 选项只能有一个 根元素</li><li>全局注册的组件 Vue.componet 必须写在 new Vue 之前。</li></ol><p><strong>vue 实例也可以设置 template 选项，当有tempalte选项的时候，挂载点会整个被tempalte模板内容给替换。</strong></p><h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ComponentA = &#123; /* ... */ &#125;</span><br></pre></td></tr></table></figure><h4 id="template写法"><a href="#template写法" class="headerlink" title="template写法"></a>template写法</h4><ol><li>直接使用 模板字符串的方式<ol start="2"><li>使用单文件组件   （推荐）</li><li>使用 script 标签的方式</li></ol></li></ol><h3 id="组件的通信"><a href="#组件的通信" class="headerlink" title="组件的通信"></a>组件的通信</h3><h4 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h4><p>我们可以通过 Prop 向子组件传递数据。用一个形象的比喻来说，父子组件之间的数据传递相当于自上而下的下水管子，只能从上往下流，不能逆流。这也正是 Vue 的设计理念之单向数据流。</p><h4 id="emit"><a href="#emit" class="headerlink" title="$emit"></a>$emit</h4><p>$emit英式发音：[iˈmɪt]。官方说法是触发当前实例上的事件。附加参数都会传给监听器回调。按照我的理解不知道能不能给大家说明白，先简单看下代码吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;my-button @greet=&quot;sayHi&quot;&gt;&lt;/my-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  复制代码let MyButton = Vue.extend(&#123;</span><br><span class="line">  template: &apos;&lt;button @click=&quot;triggerClick&quot;&gt;click&lt;/button&gt;&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      greeting: &apos;vue.js!&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    triggerClick () &#123;</span><br><span class="line">      this.$emit(&apos;greet&apos;, this.greeting)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    MyButton</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sayHi (val) &#123;</span><br><span class="line">      alert(&apos;Hi, &apos; + val) // &apos;Hi, vue.js!&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>复制代码你可以狠狠的戳这里查看Demo! 大致逻辑是酱婶儿的：当我在页面上点击按钮时，触发了组件 MyButton 上的监听事件 greet，并且把参数传给了回调函数 sayHi 。说白了，当我们从子组件 Emit（派发） 一个事件之前，其内部都提前在事件队列中 On（监听）了这个事件及其监听回调。其实相当于下面这种写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$on(&apos;greet&apos;, function sayHi (val) &#123;</span><br><span class="line">  console.log(&apos;Hi, &apos; + val)</span><br><span class="line">&#125;)</span><br><span class="line">vm.$emit(&apos;greet&apos;, &apos;vue.js&apos;)</span><br><span class="line">// =&gt; &quot;Hi, vue.js&quot;</span><br></pre></td></tr></table></figure></p><h3 id="watch的特殊情况"><a href="#watch的特殊情况" class="headerlink" title="watch的特殊情况"></a>watch的特殊情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">//1,全局监听</span><br><span class="line">        msg (newVal, oldVal) &#123;</span><br><span class="line">          console.log(&apos;msg 改变了&apos;);</span><br><span class="line">        &#125;,</span><br><span class="line">//2深入监听</span><br><span class="line">        // userInfo: &#123;</span><br><span class="line">        //   handler (newVal, oldVal) &#123;</span><br><span class="line">        //     console.log(&apos;userInfo 改变了&apos;);</span><br><span class="line">        //   &#125;,</span><br><span class="line"></span><br><span class="line">        //   deep: true//深入监听</span><br><span class="line">        // &#125;</span><br><span class="line">//3指定监听</span><br><span class="line">        &apos;userInfo.name&apos;: [</span><br><span class="line">          function () &#123;</span><br><span class="line">            console.log(&apos;1&apos;)</span><br><span class="line">          &#125;,</span><br><span class="line"></span><br><span class="line">          function () &#123;</span><br><span class="line">            console.log(&apos;2&apos;)</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="props验证与默认值"><a href="#props验证与默认值" class="headerlink" title="props验证与默认值"></a>props验证与默认值</h3><p> 1数组模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: [&apos;title&apos;],</span><br></pre></td></tr></table></figure></p><p>  2对象模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">       // key - prop</span><br><span class="line">       // value - 好几种写法，可以对这个prop做一些类型校验。默认值处理之类的。</span><br><span class="line">       // title: String,    // title 字符串类型</span><br><span class="line"></span><br><span class="line">       title: &#123;</span><br><span class="line">         type: String,</span><br><span class="line">         default: &apos;关于页&apos;</span><br><span class="line">       &#125;,</span><br></pre></td></tr></table></figure></p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>ref 这个属性，可以写在 普通标签上，也可以写在组件标签上，</p><ol><li><p>普通标签，得到是这个标签的DOM对象</p><ol start="2"><li>组件标签，得到是这个组件的组件对象</li></ol><p>ref 用在哪个组件上，那么就需要使用哪个组件的 refs 去获取</p></li></ol><h3 id="组件的通信的特殊处理"><a href="#组件的通信的特殊处理" class="headerlink" title="组件的通信的特殊处理"></a>组件的通信的特殊处理</h3><p>触发事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$emit() // $emit 子 -&gt; 父</span><br></pre></td></tr></table></figure></p><p>监听事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$on()</span><br></pre></td></tr></table></figure></p><p>监听事件但是只监听一次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$once()</span><br></pre></td></tr></table></figure></p><p>除了使用 props 来做父-&gt;子</p><p> 还有一些特殊的操作：（但是不怎么推荐）</p><pre><code>1. ref 用在组件标签上2. $root 实例属性，可以拿到根组件的对象，也就是 new Vue 出来的实例3. $parent 实例属性，可以拿到当前组件的父组件的实例对象4. $children 实例属性，去获取子组件的实例，得到的是一个子组件实例的集合（Array）</code></pre><h3 id="兄弟组件之间与复杂关系组件之间的通信"><a href="#兄弟组件之间与复杂关系组件之间的通信" class="headerlink" title="兄弟组件之间与复杂关系组件之间的通信"></a>兄弟组件之间与复杂关系组件之间的通信</h3><p>事件总线 - 中央事件管理器 - bus</p><p>主要就是使用的 $on 与 $emit</p><p>通过一个空的vue实例对象来做为中央事件管理器。</p><h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;component :is=&quot;curTab&quot;&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure><h3 id="组件上使用v-model"><a href="#组件上使用v-model" class="headerlink" title="组件上使用v-model"></a>组件上使用v-model</h3><p>v-model 其实是一种语法糖。<br>在组件身上使用 v-model<br>需要 v-modle 绑定的数据可以在 组件中使用，并且可以通过某种形式直接去修改它。</p><ol><li>普通的事件并且是用在普通标签上的时候，$event 代表着事件对象 </li><li>如果事件是写在 组件的标签上面，$event 代表着触发这个事件的时候传递过来的参数<h3 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title="sync修饰符"></a>sync修饰符</h3></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$emit(&apos;update:title&apos;, newTitle)</span><br><span class="line"></span><br><span class="line">&lt;text-document v-bind:title.sync=&quot;doc.title&quot;&gt;&lt;/text-document&gt;</span><br></pre></td></tr></table></figure><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>默认在组件开始标签与结束标签中写的内容是不会理睬的。<br>如果需要将内容给渲染出去。就需要使用出 插槽(坑) slot</p><p>插槽模板内容： 使用组件时开始标签与闭合标签内的内容</p><p>使用顺序：</p><ol><li>思考 你的 插槽模板内容要显示在组件 template 模板的那个位置。。<ol start="2"><li>在 组件的 template 模板中 相应的位置 放置一个 slot 内置组件</li></ol></li><li><p>效果就会是：你这个插槽模板内容会替换 slot 这个组件并渲染到页面上。<br>一些情况：</p><ol><li>slot 是不限制次数的，</li><li>slot 是可以命名的。<br>slot 组件上 使用  name 属性给他命名<br>哪个插槽模板内容要放到哪个 slot 坑里面，就需要带着 name 的名字<ol start="3"><li>slot 还可以有个默认不加锁的 坑</li></ol></li></ol><h3 id="插槽的作用域"><a href="#插槽的作用域" class="headerlink" title="插槽的作用域"></a>插槽的作用域</h3><p>作用域插槽：（把组件内数据能够在插槽模板内容中使用）</p><p>使用步骤：</p></li><li><p>在 slot 标签上，写 自定义的属性，注意不能是 name2. 在 相应的 slot 的插槽模板内容上面 使用 slot-scope 接收 第一步中传递过来的 porp 集合。</p></li></ol><h3 id="插槽的新语法"><a href="#插槽的新语法" class="headerlink" title="插槽的新语法"></a>插槽的新语法</h3><p>旧的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p slot=&quot;abc&quot;&gt;我的天&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>新的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-slot:abc&gt;</span><br><span class="line">&lt;p&gt;我的地&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p><strong>一个不带 name 的 <slot> 出口会带有隐含的名字“default”</slot></strong><br><strong>v-slot:可以简写成#</strong><br><strong>v-slot 只能添加在一个 <template> 上 (只有一种例外情况)，这一点和已经废弃的 slot 特性不同。</template></strong></p><h3 id="非prop的特性"><a href="#非prop的特性" class="headerlink" title="非prop的特性"></a>非prop的特性</h3><p>非props特性: (在使用的组件的时候，在组件标签上写的特性，如果组件内部没有通过props选项去指定，那么这个 特性就叫做 非props特性), 非props特性会自动写入到组件的根元素上<br>非props特性替换的情况:<br>合并的情况：（class  yu  style）<br>禁用非props特性的自动写入到组件根元素上这个规则， 但是 class 与 style 除外。</p><ol><li>$attrs 与我们 inheritAttrs 没有关系。</li><li>$attrs 与 inheritAttrs 结合起来使用可以帮我们做一些事情，把这些非props特性写到组件的其他元素上。<br>基础组件：（将项目常用的一些基础html标签给做一个简单的封装。</li></ol><h3 id="生命周期图"><a href="#生命周期图" class="headerlink" title="生命周期图"></a>生命周期图</h3><p><img src="/2019/06/02/vue基本掌握内容/ce0b40b24af5aff99b5fc8c085a073ab.bmp" alt="图解"></p><h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p><p>执行 GET 请求// 为给定 ID 的 user 创建请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&apos;/user?ID=12345&apos;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">// 可选地，上面的请求可以这样做</span><br><span class="line">axios.get(&apos;/user&apos;, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: 12345</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">执行 POST 请求axios.post(&apos;/user&apos;, &#123;</span><br><span class="line">  firstName: &apos;Fred&apos;,</span><br><span class="line">  lastName: &apos;Flintstone&apos;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function (response) &#123;</span><br><span class="line">  console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以通过向 axios 传递相关配置来创建请求axios(config)//<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">发送 POST 请求axios(&#123;</span><br><span class="line">method: &apos;post&apos;,</span><br><span class="line">  url: &apos;/user/12345&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Fred&apos;,</span><br><span class="line">    lastName: &apos;Flintstone&apos;</span><br><span class="line">  &#125;&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-数据监测不到更新操作-和-列表渲染的维护状态&quot;&gt;&lt;a href=&quot;#1-数据监测不到更新操作-和-列表渲染的维护状态&quot; class=&quot;headerlink&quot; title=&quot;1-数据监测不到更新操作 和 列表渲染的维护状态&quot;&gt;&lt;/a&gt;1-数据监测不到更新操作 和
      
    
    </summary>
    
    
      <category term="vue基础" scheme="http://yoursite.com/tags/vue%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript运行机制</title>
    <link href="http://yoursite.com/2019/05/16/JavaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/16/JavaScript运行机制/</id>
    <published>2019-05-16T01:18:47.000Z</published>
    <updated>2019-06-02T08:50:28.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="你真懂JavaScript运行机制吗1？"><a href="#你真懂JavaScript运行机制吗1？" class="headerlink" title="你真懂JavaScript运行机制吗1？"></a>你真懂JavaScript运行机制吗1？</h1><p>说起javascript（以下简称js）这门语言，相信大家已经非常熟悉了，不管是前端开发还是后端开发几乎无时无刻都<br>要跟它打交道。虽说开发者每天几乎都要操作js，但是你真的确定你掌握了js的运行机制吗！下面我们就来聊聊这<br>话题。</p><h1 id="JavaScript运行机制图解"><a href="#JavaScript运行机制图解" class="headerlink" title="JavaScript运行机制图解"></a>JavaScript运行机制图解</h1><p><img src="/2019/05/16/JavaScript运行机制/图解.png" alt="图解"><br>上图我们可以分为两部分：浏览器中的 JS引擎 和 运行环境Runtime ，那它们的区别是什么？</p><ul><li>JS引擎：编译并执行代码的地方。<br>如上图中可以看出JS引擎分为两大核心部分： 栈和堆<br>栈（Stack）:js代码的执行都要压到此栈中执行。<br>堆：存放对象、数组的地方，js垃圾回收就是检查这里。</li><li>Runtime：浏览器的运行环境，它提供了一些对外接口供JS调用，以及跟外界打交道。</li></ul><h1 id="JavaScript引擎是单线程"><a href="#JavaScript引擎是单线程" class="headerlink" title="JavaScript引擎是单线程"></a>JavaScript引擎是单线程</h1><p>JS引擎是单线程的，也就是说在一个时间段内，事情只能一件一件的按先后顺序去做，第一件事没做完就不能第二<br>件事。那么在js引擎中负责解释和执行js代码的线程只有一个，我们可以称之为 主线程 。<br>当然浏览器的运行环境Runtime还提供一些其他的线程，如定时器线程、ajax线程、事件线程、网络请求和UI渲染<br>的线程，为了和js主线程分开，我们这里都统称它们为 工作线程 。<br>由于浏览器是多线程的，所以工作线程和js主线程都可以执行任务，线程间互不干扰。</p><h1 id="JavaScript引擎是单线程-1"><a href="#JavaScript引擎是单线程-1" class="headerlink" title="JavaScript引擎是单线程"></a>JavaScript引擎是单线程</h1><p>JS引擎是单线程的，也就是说在一个时间段内，事情只能一件一件的按先后顺序去做，第一件事没做完就不能第二<br>件事。那么在js引擎中负责解释和执行js代码的线程只有一个，我们可以称之为 主线程 。<br>当然浏览器的运行环境Runtime还提供一些其他的线程，如定时器线程、ajax线程、事件线程、网络请求和UI渲染<br>的线程，为了和js主线程分开，我们这里都统称它们为 工作线程 。<br>由于浏览器是多线程的，所以工作线程和js主线程都可以执行任务，线程间互不干扰。</p><h1 id="JavaScript同步（异步）任务"><a href="#JavaScript同步（异步）任务" class="headerlink" title="JavaScript同步（异步）任务"></a>JavaScript同步（异步）任务</h1><p>在JavaScript任务可以分为两种：</p><ul><li>同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务，若前一个任务耗<br>费很长时间，则后面的任务会一直处于等待状态，即阻塞状态。</li><li>异步任务：在栈执行代码的过程中，如遇到异步函数，如setTimeout、异步Ajax、事件处理程序，会将这些<br>异步代码交给浏览器的工作线程来处理，我们把这些任务称之为异步任务。异步任务是不进入主线程，而是<br>进入任务队列（queue task）。<ul><li>什么异步函数？<br>异步函数通常是由发起函数和回调函数构成的。如：<br>A（callback）<ul><li>函数A就是发起函数</li><li>callback就是回调函数<br>它们都是在主线程调用的，其中发起函数用来发起异步过程，回调函数用来处理结果。<br>如：<code>setTimeout(callback,1000)</code><br>setTimeout就是发起函数、callback就是回调函数。</li></ul></li></ul></li></ul><p>如： <code>异步的Ajax</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new new XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = callback; //callback为回调函数</span><br><span class="line">xhr.open(&apos;get&apos;,url,true);</span><br><span class="line">xhr.send(null); // send为发起函数</span><br></pre></td></tr></table></figure></p><p>可以看出发起函数和回调函数也可以是分离的。</p><p>既然同步任务是在主线程中执行的，那么异步任务何时执行？<br>答：是这样的，一旦栈中同步任务执行完毕后，系统就会通过 事件循环 机制读取任务队列中的任务一个个移<br>到栈中去执行。</p><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>当主线程中的任务执行完毕后，会从任务队列中获取任务一个个的放在栈中执行去执行，这个过程是循环不断的，<br>所以整个的这种运行机制又称为事件循环。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>在js中，代码最终都是在栈中执行的，栈结构的特点是：<strong>先进后出，后进先出</strong>。<br>我们来看下面代码的运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function bar()&#123;</span><br><span class="line">console.log(1);</span><br><span class="line">foo();</span><br><span class="line">&#125;</span><br><span class="line">function foo()&#123;</span><br><span class="line">par();</span><br><span class="line">console.log(3);</span><br><span class="line">&#125;</span><br><span class="line">function par()&#123;</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">console.log(2);</span><br><span class="line">&#125;,0);</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure></p><p>运行的最终结果是：132。 为什么结果不是123呢？<br>下我们来分析下代码运行时入栈和出栈的过程。</p><p>首先当调用函数 bar() 时，此函数就会先入栈，其内部的 console.log(1) 也会随之入栈执行。<br><img src="/2019/05/16/JavaScript运行机制/1.png" alt="1"><br>执行完console.log(1)后，就要出栈，于是控制台先打印出结果1，只剩下bar()在栈中。接着再执行函数bar内部的<br>函数foo，于是函数foo也开心的入栈了。<br><img src="/2019/05/16/JavaScript运行机制/2.png" alt="2"><br>执行函数foo的内部代码，调用函数 par() ，于是函数par()也要跟着入栈。<br><img src="/2019/05/16/JavaScript运行机制/3.png" alt="3"><br>由于函数par()内部执行遇到了 异步函数setTimeout ,异步函数则会由浏览器的Runtime运行环境的工作线程来处<br>理，等定时器设置的时间到达就会被放到任务队列中，此时栈的同步任务继续执行。<br><img src="/2019/05/16/JavaScript运行机制/gz.png" alt="gz"><br>接着在执行par函数中的 console.log(3) ,控制台打印结果为3 ,此时栈的代码执行完毕后，会按照栈的特点进行<br><strong>先进后出，后进先出</strong>顺序进行 出栈 。出栈顺序：<strong>先函数par()—-》后函数foo()</strong>—-》<strong>最后函数bar</strong>.</p><p>最后只剩下异步任务，由主线程去获取任务队列中的任务放在栈中去执行。也可以认为栈中的同步代码执行总是在<br>读取 异步任务 之前执行。<br><img src="/2019/05/16/JavaScript运行机制/5.png" alt="5"><br>最后执行setTimeout中的回调函数：结果控制台输出为2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">console.log(2);</span><br><span class="line">&#125;,0);</span><br></pre></td></tr></table></figure></p><p>所以最终代码的运行结果为132。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>js引擎是单线程执行js代码，同步任务在栈中按顺序执行，如果某一个同步任务没有执行完毕，则后面的代码<br>将会处于阻塞等待状态</li><li>栈中若执行遇到了异步任务（如定时器、异步Ajax、事件），会将此异步任务通过浏览器对应的工作线程来<br>处理。</li><li>工作线程中的所有异步任务均会按照设定的时间进行等待，时间一到会被加入任务队列。如果是异步ajax,则<br>等待其返回结果在加入到任务队列</li><li>当栈中为空时，会通过事件循环来一个个获取任务队列中的任务放到栈中进行逐个运行。即栈中的同步任务<br>总是在读取 异步任务 之前执行</li><li>定时器设置的时间不一定按照设定的时间进行执行，这得取决于栈中同步任务耗费的时间。因为栈中执行的<br>同步任务如果耗费很长时间，则会影响到异步任务回调函数的执行。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;你真懂JavaScript运行机制吗1？&quot;&gt;&lt;a href=&quot;#你真懂JavaScript运行机制吗1？&quot; class=&quot;headerlink&quot; title=&quot;你真懂JavaScript运行机制吗1？&quot;&gt;&lt;/a&gt;你真懂JavaScript运行机制吗1？&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
</feed>
