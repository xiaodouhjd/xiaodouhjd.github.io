<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue反向代理]]></title>
    <url>%2F2019%2F06%2F15%2Fvue%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[反向代理A - C - B 前端代码的访问地址 - http://118.89.203.190/maizuo后端接口的方位地址 - http://118.89.203.190:8080 同一台服务器 使用反向代理（nginx) http://118.89.203.190/maizuo -&gt; http://118.89.203.190 -&gt; http://118.89.203.190:8080 目前我们的vue项目的情况http://118.89.203.190/maizuo -&gt;http://118.89.203.190/mg/lovev/miguMovie/data/seeFilmData.jsp -&gt;D http://118.89.203.190:9090/mg/lovev/miguMovie/data/seeFilmData.jsp -&gt;http://movie.miguvideo.com/lovev/miguMovie/data/seeFilmData.jsp ? C - B 需要使用nginx反向代理，但是 c - B是不同的两个服务器的服务，nginx是没办法直接去代理的, 它只能是，把同一台服务器上的 80的服务代理到其他的端口服务 （80 -&gt; 9090） 这时，我们需要在自己的服务器上启动一个 9090 的nodejs服务 安装 nodejs 启动一个后台的服务，服务监听的端口是 9090 （express） 2.0 在 你自己的电脑上吧 express 项目写好 创建一个server.js 123456789101112131415161718const express = require(&apos;express&apos;);const proxy = require(&apos;http-proxy-middleware&apos;);const app = express();app.get(&apos;/&apos;, (req, res) =&gt; &#123; res.send(&apos;hello world, 我是一个nodejs服务&apos;);&#125;)// http://118.89.203.190:9090/mg/lovev/miguMovie/data/seeFilmData.jsp -&gt; http://movie.miguvideo.com/lovev/miguMovie/data/seeFilmData.jspapp.use(&apos;/mg&apos;, proxy(&#123; target: &apos;http://movie.miguvideo.com&apos;, changeOrigin: true, // 主动修改 请求头的 origin ，以防止有些服务对它的限制 pathRewrite: &#123; &apos;^/mg&apos;: &apos;&apos; &#125;&#125;))app.listen(9090) express 这个项目，要将 9090 的地址转发到真实的服务器上，需要使用 http-proxy-middleware 这个模块 3.1 npm install –save http-proxy-middleware 3.2 对 9090 上某个请求做转发 express 这个项目代理配置成功之后，将 node_models 给删除掉再上传到服务器的 /root 目录下 到 服务的 这个express 项目 npm install 。然后启动它 5.1 为了让 这个后台项目长久运行正常，我们需要守护他的进程 5.2 npm install -g pm2 接下来，完成 80 -&gt; 9090 服务的反向代理处理 6.1 找到 nginx 配置文件所在的路径 /etc/nginx/conf.d/default.conf 6.2 先不要着急去修改这个文件，可以先备份一下。(确保，你已经在 /etc/nginx/conf.d)cp default.conf default.conf.bak 6.3 去修改 default.conf (推荐吧这个文件传到本地电脑上来改，改完之后再上传回去) 6.4 测试 nginx 配置文件是否有明确的问题 nginx -t 6.5 重启 nginx nginx -s reload 6.6 测试]]></content>
      <tags>
        <tag>vue反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue正向代理]]></title>
    <url>%2F2019%2F06%2F15%2Fvue%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[16-2正向代理跨域 只会产生在浏览器上。 域名，端口，协议三者有一个不同，就会跨域 如果是后台代码，向别人的网站偷数据，是不会有跨域问题的。 正向代理1.0.0.1 -&gt; www.facebook.com 1.0.0.1 -&gt; 128.28.28.28 -&gt; www.facebook.com localhost:8080 -&gt; m.maoyan.com 跨域 localhost:8080 -&gt; localhost:8080/后台服务 -&gt; m.maoyan.com 1.在文件夹根目录下创建一个vue.comfig.jsvue-cli3.0 需要自己去手动添加vue.config.js文件123456789101112131415161718192021222324252627282930313233343536// 配置文件module.exports = &#123; // 选项 devServer: &#123; // port: 9090 // 正向代理的配置 // http://localhost:8080/api/find =&gt; http://m.maoyan.com/api/find // proxy: &apos;http://i.waimai.meituan.com/&apos; proxy: &#123; // key - 请求前缀 // value - 代理选项设置 // http://localhost:8080/maoyan/api/find =&gt; http://m.maoyan.com/api/find &apos;/maoyan&apos;: &#123; target: &apos;http://m.maoyan.com/&apos;, pathRewrite: &#123; &apos;^/maoyan&apos;: &apos;&apos; &#125; &#125;, &apos;/meituan&apos;: &#123; target: &apos;http://i.waimai.meituan.com/&apos;, pathRewrite: &#123; &apos;^/meituan&apos;: &apos;&apos; &#125; &#125;, &apos;/mg&apos;: &#123; target: &apos;http://movie.miguvideo.com/&apos;, pathRewrite: &#123; &apos;^/mg&apos;: &apos;&apos; &#125; &#125; &#125; &#125;&#125; 2请求直接改成本地网络就OK了 123456//http://localhost:8080 axios.get(&apos;http://localhost:8080/maoyan/ajax/cinemaList&apos;) .then(response =&gt; &#123; let res = response.data console.log(res) &#125;) 正向代理的一些问题 只能用在开发阶段 上线阶段，如果前端代码与后台代码是同一个服务，那么不涉及跨域问题，那么就不要正向代理。如果前端代码与后台代码不是同一个服务。这个时候是借助nginx的代理配置来代理请求。如果跨域，可以配置 nginx 的反向代理。 axios - post请求参数问题 很多时候，你会发现，我们用 axios 发生 post 请求，后台告诉你，接收不到你传递过来的参数 让后台改 前端自己改]]></content>
      <tags>
        <tag>正向代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue脚手架]]></title>
    <url>%2F2019%2F06%2F15%2Fvue%E8%84%9A%E6%89%8B%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[vue脚手架vue脚手架官网 首先安装脚手架:123npm install -g @vue/cliORyarn global add @vue/cli 这个命令来检查其版本是否正确:1vue --version 创建一个项目1vue create hello-world 最后把自己所需的选项选好，命名就创建完成了 使用图形化界面1vue ui 开发时1npm run serve 生产上线时1npm run build 测试1npm run test 运行 eslint 的检查，并且会自动修复一些 eslint 的错误1npm run lint 项目的目录结构1234567891011121314151617- public 静态资源文件夹，它里面的内容是不需要 webpack 做打包构建的内容。 - favicon.ico - index.html 用于 webpack 主动生成 index.html 的模板- src 项目源文件夹，你写代码的位置。这个里面的所有内容，都会经过webpack的打包构建 - assets 静态资源文件夹，这个里面主要放 css img font 之类的东西， - components vue的组件 - App.vue 老二组件 - main.js 项目的入口js文件- .browserslistrc 浏览器的兼容配置文件，它主要是给到 postcss 使用的。- .editorconfig 告诉我们编辑器的配置- .eslintrc.js eslint 的规则配置文件- .gitignore git 忽略文件- babel.config.js babel 的配置，.babelrc- package-lock.json npm 锁文件- package.json npm 依赖项，与当前项目的描述- postcss.config.js postcss 的配置文件- README.md 读我文件 项目启动假数据 -1. 自己写json文件 假数据应该放到 public 文件夹下 todos.json 2. mockjs 一款能够创建假数据，并且这个假数据还有些真实的工具。它主要是拦截我们的ajax请求来实现。 安装 1npm install --save mockjs 去编写 mockjs 的拦截代码 src/mockdata/index.js 在 main.js 中，引入第2步中的文件 json-server 前端开发，很多时候，我们前端的页面已经做好了，下一步就是要跟后台做接口的联调，但是这个时候后台可能还没有写完。这个时候就需要我们自己来造假数据，好使前端的业务逻辑能够跑起来。使用 json-server 来模拟假数据 todo.json { data: [ { name: ‘吃饭’, id: 1 }, { name: ‘睡觉’, id: 2 } ]} { data: [ { aname: ‘吃饭’, aid: 1 }, { aname: ‘睡觉’, aid: 2 } ]}json-server官网入门前端人员开发必备 安装JSON服务器1npm install -g json-server 创建db.json包含一些数据的文件123456789&#123; &quot;posts&quot;: [ &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; &#125; ], &quot;comments&quot;: [ &#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 &#125; ], &quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;&#125; 启动JSON服务器1json-server --watch db.json 路线根据以前的db.json文件，这里是所有默认路由。您还可以使用添加其他路线–routes。多条路线123456GET /postsGET /posts/1POST /postsPUT /posts/1PATCH /posts/1DELETE /posts/1 最后封装axios 在 src 下面 新建一个文件 src/utils/http.js 在 http.js 中做封装，并且暴露出去 在 main.js 将 2 中的东西给添加到 vue 的原型上面。后续可以使用 this.$http 来使用 // 1. 引入 axios1import axios from &apos;axios&apos;; // 2. 生成一个 axios 的实例1const http = axios.create(); // 3. 设置 http 的一些默认选项12http.defaults.baseURL = process.env.NODE_ENV === &apos;production&apos; ? &apos;http://www.baidu.com/&apos; : &apos;http://localhost:3000/&apos;; // 基准url地址http.defaults.timeout = 10000; // 超过这个时间点请求还没有完成，那么就报错。 // 4. 做请求的拦截 // 5. 做响应的拦截123http.interceptors.response.use(response =&gt; &#123; return response.data;&#125;) // 6. 不要忘了暴露1export default http; // http.get()// http.post()// http.delete()]]></content>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router]]></title>
    <url>%2F2019%2F06%2F15%2Fvue-router%2F</url>
    <content type="text"><![CDATA[前端路由 vue-router两种应用 单页面应用（SPA）single-page-application 多页面应用（MPA）一个项目中有多个html文件的。 vue-router 安装vue-router 1npm install --save vue-router 项目中选择某个位置放入一个坑 router-view 这个组件 项目中配置路由规则，最后要暴露出去路由器的实例对象 在main.js中也就是 new Vue 的地方需要将第3步中暴露出来的 router 实例对象配置给 根组件 的 router 选项 router的使用 引入 vue 1import Vue from &apos;vue&apos; 引入 vue-router 1import VueRouter from &apos;vue-router&apos; 1.1 引入路由页面级别组件1import Home from &apos;../views/Home.vue&apos; 使用 VueRouter 插件 1Vue.use(VueRouter) 配置路由规则 [{}, {}, {}] 123456789101112131415161718const routes = [ &#123; path: &apos;/home&apos;, component: Home, children: [ &#123; // /home/page1 path: &apos;page1&apos;, name: &apos;page1&apos;, component: Page1 &#125;, &#123; // /home/page2 path: &apos;page2&apos;, name: &apos;page2&apos;, component: Page2 &#125; ] 实例化路由器对象 123const router = new VueRouter(&#123; routes&#125;) 将第4步中的东西给暴露出去 router-view标签(坑) router-link标签 这也是使用了 路由之后，提供给我们的一个全局组件，它就是一个 a 标签，能帮我们实现路由的切换他还有个replace属性 to 功能与href相似 active-class 能够让我们修改默认高亮的类的名字 默认值是 ‘router-link-active’ router-link 与 a 标签的区别 默认情况下，写不写 # 的问题 router-link 可以帮我们实现高亮的效果 动态路由匹配当我们使用上路由之后，会在 Vue 的原型上挂载 两个属性 $route 当前匹配的路由对象信息 $router 路由器的实例对象 编程式导航 - 通过js代码来控制路由的跳转$router.push() 跳转页面，新增一个历史记录 $router.back() 后退 $router.forward() 前进 $router.go() 根据参数来看是前进还是后退 $router.replace() 重定向页面，不加历史记录 命令路由 在路由规则上给每个规则加上name属性，后续方便我们操作路由的跳转12&lt;router-link to=&quot;/home/page1&quot;&gt;&lt;/router-link&gt;&lt;router-link :to=&quot;&#123; path: &apos;/home/page1&apos;, name: &apos;page1&apos;, query: &#123;&#125;, params: &#123;&#125; &#125;&quot;&gt;&lt;/router-link&gt; to属性传对象的时候，可以有如果属性 path 路由路径 name 命名路由的名字 query search参数 params 动态路由匹配参数 PS: params 与 path 不能共存，如果你要传递 params，那么不要使用 path 命名视图 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar (侧导航) 和 main (主内容) 两个视图，这个时候命名视图就派上用场了。如果 router-view 没有设置名字，那么默认为 default。1&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt; 一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components配置 (带上 s)：1234567891011const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/&apos;, components: &#123; default: Foo, a: Bar, b: Baz &#125; &#125; ]&#125;) 重定向和别名redirect重定向“重定向”的意思是，当用户访问 /a时，URL 将会被替换成 /b，然后匹配路由为 /b1234const router = new VueRouter(&#123; routes: [ &#123; path: &apos;*&apos;, redirect: &apos;/b&apos; &#125; ]&#125;) 重定向的目标也可以是一个命名的路由：1234const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/a&apos;, redirect: &#123; name: &apos;foo&apos; &#125;&#125; ]&#125;) 甚至是一个方法，动态返回重定向目标：1234567const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/a&apos;, redirect: to =&gt; &#123; // 方法接收 目标路由 作为参数 // return 重定向的 字符串路径/路径对象 &#125;&#125; ]&#125;) 别名“别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。1234const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/a&apos;, component: A, alias: &apos;/b&apos; &#125; ]&#125;) 路由组件传参在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。 使用 props 将组件和路由解耦：取代与 $route 的耦合12345const User = &#123; template: &apos;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&apos;&#125;const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/user/:id&apos;, component: User &#125; ]&#125;) 通过 props 解耦12345678910111213const User = &#123; props: [&apos;id&apos;], template: &apos;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&apos;&#125;const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/user/:id&apos;, component: User, props: true &#125;, // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项： &#123; path: &apos;/user/:id&apos;, components: &#123; default: User, sidebar: Sidebar &#125;, props: &#123; default: true, sidebar: false &#125; &#125; ]&#125;) 布尔模式如果 props 被设置为 true，route.params 将会被设置为组件属性。 对象模式如果 props 是一个对象，它会被按原样设置为组件属性。当 props 是静态的时候有用。1234const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/promotion/from-newsletter&apos;, component: Promotion, props: &#123; newsletterPopup: false &#125; &#125; ]&#125;) 函数模式你可以创建一个函数返回 props。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。1234const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/search&apos;, component: SearchUser, props: (route) =&gt; (&#123; query: route.query.q &#125;) &#125; ]&#125;) vue路由的两种模式 hash (默认) history 要修改当前路由模式可以在 实例化 路由器对象的时候设置 mode 选项123new VueRouter(&#123; mode: 'history'&#125;) 这两种模式的区别 从外观上来说，hash模式会在url地址上面有一个 # 号，而 history 没有，更像url地址。 从原理上来说，hash模式是通过 window.onHashChagne 这个事件来处理的。而 history 模式是基于 html5 中 history 新增的一些api. hisotry.pushState() history.replaceState() window.onpopstate 来实现的 hisotry模式还需要后台配置去处理上线的404的问题 nprogress更多用法适用于Ajax’y应用程序的超薄进度条。受Google，YouTube和Medium的启发。 将nprogress.js和nprogress.css添加到项目中。12&lt;script src=&apos;nprogress.js&apos;&gt;&lt;/script&gt;&lt;link rel=&apos;stylesheet&apos; href=&apos;nprogress.css&apos;/&gt; NProgress可通过bower和npm获得。1$ npm install --save nprogress 基本用法只需致电start()并done()控制进度条即可。12NProgress.start（）;NProgress.done(); vue 导航守卫主要分为三个大块 全局 全局前置 beforeEach 全局解析守卫 beforeResolve 全局后置 afterEach 路由独享的 beforeEnter 进入当前路由时 组件级别的 beforeRouteEnter 进入当前组件时 beforeRouteUpdate 当前组件更新时 beforeRouteLeave 退出当前组件时 全局前置守卫 接收一个函数，函数中有三个参数： to - 要去的路由 from - 来自哪个路由 next - 是一个方法，要不要他去 next 如果直接调用，那么就相当于放行 如果调用，但是传递了一个 false, 那么就不放行 如果不调用，也不放行。 调用，并且里面可以传递路由的path路径或者是路由的对象信息。那么就可以重定向到我们的参数中所指定的位置。 全局后置守卫，后置守卫没有 next 导航守卫的钩子函数 在路由发生变化的时候会主动触发的一些函数 作用场景 beforeEach 与 afterEach 能实现页面进度条的效果 登录拦截 先排除 组件级别 afterEach 排除 正常情况下，如果是后台管理系统的话，因为处理登录与注册页面之外其他的都需要做登录的拦截，那么就可以再 全局前置 里面去做。如果项目中只有那么一个到两个需要做拦截的页面，那么就可以再他们自己的路由独享里面去做。 判断是否登录例子123456789101112131415161718192021222324router.beforeEach((to, from, next) =&gt; &#123; NProgress.start() // 路由拦截 if (to.meta.requireLogin) &#123; // 判断是否有登录 if (window.localStorage.getItem(&apos;userInfo&apos;)) &#123; // 有登录 next() &#125; else &#123; // 没有登录 // next(&apos;/login&apos;) console.log(to) next(&#123; path: &apos;/login&apos;, query: &#123; redirect: to.fullPath &#125; &#125;) &#125; &#125; else &#123; next() &#125;&#125;) 路由元信息定义路由的时候可以配置 meta 字段：123456789101112131415const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/foo&apos;, component: Foo, children: [ &#123; path: &apos;bar&apos;, component: Bar, // a meta field meta: &#123; requiresAuth: true &#125; &#125; ] &#125; ]&#125;) 我们称呼 routes 配置中的每个路由对象为 路由记录。路由记录可以是嵌套的，因此，当一个路由匹配成功后，他可能匹配多个路由记录例如，根据上面的路由配置，/foo/bar 这个 URL 将会匹配父路由记录以及子路由记录。一个路由匹配到的所有路由记录会暴露为 $route 对象 (还有在导航守卫中的路由对象) 的 $route.matched 数组。因此，我们需要遍历 $route.matched 来检查路由记录中的 meta 字段。下面例子展示在全局导航守卫中检查元字段：123456789101112131415router.beforeEach((to, from, next) =&gt; &#123; if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123; // this route requires auth, check if logged in // if not, redirect to login page. if (!auth.loggedIn()) &#123; next(&#123; path: &apos;/login&apos;, query: &#123; redirect: to.fullPath &#125; &#125;) &#125; else &#123; next() &#125; &#125; else &#123; next() // 确保一定要调用 next() &#125;&#125;)]]></content>
      <tags>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex总结]]></title>
    <url>%2F2019%2F06%2F15%2Fvuex%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[vuex什么时候需要使用 vuex 当你不知道该不该用的时候，那就是不该用。（你自会知道什么时候需要用到它） 组件之间通信很复杂的情况下 项目中使用了路由，并且路由页面组件中需要通信的时候， 项目写着写着头发一大把掉的时候。 vuex的操作流程 先要有仓库，将我们项目中组件上需要共享的数据放置到我们 仓库中 state 的位置。 组件要使用 仓库 中 state 的数据，就从仓库里面拿出来用。 要修改仓库中 state 的数据， commit(提交) mutation dispath(派发) action -&gt; commit mutation 然后仓库中 state 数据发生变化，组件就会得到更新 vuex 的使用 安装 1vuex `npm install --save vuex` 项目中 src/store/index.js 文件中创建仓库的实例对象 要 main.js new Vue 的地方配置一个 store 的选项。选项的值就是 2 中 仓库实例对象 引入 vue 1import Vue from &apos;vue&apos; 引入 vuex 1import Vuex from &apos;vuex&apos; 调用 vuex 1Vue.use(Vuex) 创建 仓库的实例对象 1234567891011121314151617const store = new Vuex.Store(&#123; state: &#123; title: &apos;hello-world&apos;&#125;,getters: &#123;// key - getter 的名字 // value - 值 函数，要有 return // key: value&#125;,mutations: &#123; // key - mutation 的名字 // value - 函数 接收到 state // key: value&#125;,actions: &#123;&#125;&#125;) 暴露 store 1export default store; State对象展开运算符12345computed: &#123; localComputed () &#123;&#125;, ...mapState(&#123;&#125;)&#125;也可以使用`...mapState([])`,但前提是映射的计算属性的名称与state的子节点名称相同，如果state在vuex的modules中，则不成功。 mapState 辅助函数四种用法123456789101112computed: mapState(&#123; // 箭头函数可使代码更简练 count: state =&gt; state.count, // 传字符串参数 &apos;count&apos; 等同于 `state =&gt; state.count` countAlias: &apos;count&apos;, // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;) 123computed: mapState([ // 映射 this.count 为 store.state.count &apos;count&apos;]) 如何将仓库中的数据拿到组件中去使用this.$store 就是仓库的实例对象 直接使用 this.$store 的方式在组件 template 模板中使用 （不推荐） 组件中使用 计算属性 去拿 仓库的数据 12345computed: &#123; title () &#123; return this.$store.state.title &#125;&#125; 借助 vuex 提供的辅助函数 mapStatemapState([]) - 组件的computed 的 key 必须要跟仓库中 state 里面某个key 相同mapState({}) - 组件的computed 的 key 可以自定义。 将 mapState 与 组件自身的 computed 结合 （推荐） 123456computed: &#123; ...mapState(['title']), firstName () &#123; return this.name.split('')[0] &#125;&#125;, GettermapGettersmapGetters将store中的getter映射到局部计算属性12345678computed: &#123; ...mapGetters([ &apos;oneGetter&apos;, &apos;anotherGetter&apos; ])， ...mapGetters(&apos;命名空间的模块名&apos;,[ &apos;oneGetter&apos;, &apos;anotherGetter&apos; ])//第二个获取这个名字的数据&#125; Mutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。 mapMutations使用mapMutations辅助函数将组件中的methods映射为store.commit调用。1234methods: &#123; // 将this.tips映射成 this.$store.commit(&apos;tips&apos;) ...mapMutations([&apos;tips&apos;])&#125; 提交载荷（Payload）你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）：12345// ...mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125; 123//第一个是方法名，第二个是参数store.commit(&apos;increment&apos;, &#123; amount: 10&#125;) 提交 mutation 的另一种方式是直接使用包含 type 属性的对象：123store.commit(&#123; type: &apos;increment&apos;, amount: 10&#125;) 使用常量替代 Mutation 事件类型,一条重要的原则就是要记住 mutation 必须是同步函数 如何修改仓库中的数据 先需要在仓库中定义我们的mutation 在组件中提交这个mutaion this.$store.commit(‘mutaion的名字’, 要传递的参数) this.$store.commit({type: mutaion的名字,其余的参数}) mapMutations 辅助函数 mutation不允许异步代码的actions mapAction使用mapActions辅助函数将组件的methods映射成store.dispatch调用1234567//第一个是命名空间的名字，模块名，第二个触发的方法名//当项目只有一个模块时methods: &#123; // 将this.tips映射成 this.$store.dispatch(&apos;tips&apos;) ...mapActions(&apos;tips&apos;,[&apos;tips&apos;]) ...mapActions([&apos;tips&apos;])&#125; 如何写异步代码在仓库中 actions 每一个action里面都可以写异步代码，但是action并不能修改state中的数据，真正修改数据的还是 mutaction 在组件中如何派发这个action this.$store.dispatch(‘action的名字’) mapActions 辅助函数 vuex 分析图： 10-命名空间为什么推荐大家在做 vuex moduels 每个模块都加上 命令空间呢 操作方便 mapState([‘todos’]) 根仓库上拿toods mapState(‘todo’, [‘todos’]) // this.$store.state.todo.todos mapGetters(‘todo’, [‘todos’]) // this.$store.getters.todo.todos 如果 不带命名空间会造成什么影响 getters 是全局的, 如果在多个模块中有重名的 getter 会报错 mutations， actions 有重名的话，会都被执行 最后还有一个看官网]]></content>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue基本掌握内容]]></title>
    <url>%2F2019%2F06%2F02%2Fvue%E5%9F%BA%E6%9C%AC%E6%8E%8C%E6%8F%A1%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[1-数据监测不到更新操作 和 列表渲染的维护状态数组： 12345678910111213使用一些变异方法或者直接替换数组都能引起页面的更新。但是以下两个操作不会： 1. 直接根据数据下标来修改 vm.list[0] = 9; 2. 直接修改数据的长度 vm.list.length = 10;解决方式： 1. 使用 Vue.set 原型方法 2. 使用 vm.$set 实例方法 Vue.set(target, index, value); vm.$set(target, index, value); 对象1234Vue 不能检测对象属性的添加或删除：Vue.set(target, key, value);vm.$set(target, key, value); 列表渲染的维护状态 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似 Vue 1.x 的 track-by=”$index” 。 这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性： 123&lt;div v-for=&quot;item in items&quot; v-bind:key=&quot;item.id&quot;&gt; &lt;!-- 内容 --&gt; &lt;/div&gt; 建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。 因为它是 Vue 识别节点的一个通用机制，key 并不与 v-for 特别关联，key 还具有其他用途，我们将在后面的指南中看到其他用途。 不要使用对象或数组之类的非原始类型值作为 v-for 的 key。用字符串或数类型的值取而代之。 v-if 与 v-show 的区别：1. 他们都能实现元素的显示隐藏 2. v-show只是简单控制元素的display属性（不管条件为真还是为假，这个元素都会被渲染出来），而v-if才是条件渲染（条件为真，元素将会被渲染，条件为假，元素会被销毁） 3. v-show有更高的首次渲染开销。v-if的首次渲染开销要小得多。 4. v-if有更高的切换开销，v-show切换开销小 5. v-if有配套的 v-else-if 和 v-else，而v-show没有 6. v-if可以搭配template使用。而v-show不行。 在 元素上使用 v-if 条件渲染分组因为 v-if 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 元素。优点是:不影响内部布局。1234&lt;template v-if=&quot;ok&quot;&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; key 管理复用 元素仍然会被高效地复用，因为它们没有添加 key 属性。添加key属性就不会复用了。 事件修饰符 .stop .prevent .capture .self. once .passive1234567891011121314151617181920212223242526272829&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;&lt;!-- self修饰符规定的就是，这个事件只能在绑定事件的元素身上起效果。在他的内部元素身上触发事件是不生效的。。他的原理就是判断 target === currentTarget --&gt;&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt; &lt;!-- 而不会等待 `onScroll` 完成 --&gt; &lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt; &lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt; 按键修饰符在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符：12&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.enter=&quot;submit&quot;&gt; 你可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。1&lt;input v-on:keyup.page-down=&quot;onPageDown&quot;&gt; 按键码 .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right注意：有一些按键 (.esc 以及所有的方向键) 在 IE9 中有不同的 key 值, 如果你想支持 IE9，这些内置的别名应该是首选。你还可以通过全局 config.keyCodes 对象自定义 你还可以通过全局 config.keyCodes 对象自定义按键修饰符别名：12// 可以使用 `v-on:keyup.f1`Vue.config.keyCodes.f1 = 112 系统修饰键可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 .ctrl .alt .shift .meta exact 修饰符修饰符允许你控制由精确的系统修饰符组合触发的事件 鼠标按钮修饰符2.2.0 新增 .left .right .middle v-bind:class 直接使用data的数据，数据是个字符串，这个数据的字符串会直接当做class类名。 使用 对象 字面量的事项key: value, key会作为类名，value会转换成boolean类型，如果为真，这个key就会存在，如果为假，这个key就不存在 使用 数组的方式 event事件绑定的时候，事件处理函数如果没有加括号，那么我们的事件处理函数会自动接收到 event 事件对象 如果加上括号，那么 event 对象不会自动传递，如果需要，得手动传递，$event 表单绑定你可以用 v-model 指令在表单 input、textarea 及 select 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。注意：v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件： text 和 textarea 元素使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 对于需要使用输入法 (如中文、日文、韩文等) 的语言，你会发现 v-model 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用 input 事件。 计算属性参考计算属性，能对现有的data中或者现有的计算属性中的数据做二次处理（计算）。并返回新的数据，这个计算属性可以当做 data 里面的数据一样在页面中或者其他的方法中去使用。但是有一点，计算属性不能直接修改。。。。他的变化，是基于它的依赖项来的。它的依赖如果发生变化，那么他会重新计算。计算属性vs方法 计算属性有缓存，如果依赖项没有变化，那么相同的计算属性我使用多次，只会在第一次的时候执行。后续都是直接拿的缓存。而方法没有缓存 123computed: &#123; key, value &#125; // key - 计算属性的名字， // value - 是一个函数 , 他其实就是 amsg 这个计算属性的 getter 监听： watch.监听现有的data或computed中的数据，如果监听的数据有变化，那么监听的回调函数将会被执行。1watch: &#123; key,value&#125; 12345678 // key - 要监听的数据 // value - 监听的回调函数 会接收两个参数，newVal, oldVal watch: &#123; msg (newVal, oldVal) &#123; console.log(&apos;newVal: &apos;, newVal); console.log(&apos;oldVal: &apos;, oldVal); &#125;&#125; mixin 混入1234 var common = &#123;&#125;//定义一个对象，这个对象就是包含有vue组件实例相关的选项的一个对象。/data如果是一个混入对象的选项，那么data需要使用工厂模式 // 弄成一个方法，方法里面返回对象 12// 使用混入 mixins: [common], 组件参考使用组件 创建组件 全局注册 Vue.component(组件的名字，组件的选项对象) 局部注册 components 选项全局与局部的区别： 在谁的身上注册的局部组件，就只能用在这个人的身上。 全局注册的组件可以用在任意位置。必须要在 new Vue 之前去注册。 把组件当做一个自定义标签去使用组件的特性这里写法跟 mixin 很像，都是能够使用 new Vue 时传递的哪些选项。 el 与 propsData 不能用 data 必须是一个函数返回对象的形式。 组件必须要有一个选项是，template 选项，这个选项指定我们组件的内容。 组件的一些使用情况： 组件的使用，先注册，然后用组件的名字做为标签来使用。 组件必须要有一个 template 选项，来指定这个组件的模板内容。 组件的 data 选项 必须是一个函数返回对象的形式。 组件的命名，可以尽量 短横线方式。也可以使用 驼峰的方式，但是使用的时候需要换成 短横线方式。 （todo） 使用 x-template 的 script 标签的方式的时候，不需要考虑这条规则 使用 单文件组件， 也不需要考虑这条规则 组件的命名不能跟现有的html标签冲突 组件的 template 选项只能有一个 根元素 全局注册的组件 Vue.componet 必须写在 new Vue 之前。 vue 实例也可以设置 template 选项，当有tempalte选项的时候，挂载点会整个被tempalte模板内容给替换。 局部注册1var ComponentA = &#123; /* ... */ &#125; template写法 直接使用 模板字符串的方式 使用单文件组件 （推荐） 使用 script 标签的方式 组件的通信prop我们可以通过 Prop 向子组件传递数据。用一个形象的比喻来说，父子组件之间的数据传递相当于自上而下的下水管子，只能从上往下流，不能逆流。这也正是 Vue 的设计理念之单向数据流。 $emit$emit英式发音：[iˈmɪt]。官方说法是触发当前实例上的事件。附加参数都会传给监听器回调。按照我的理解不知道能不能给大家说明白，先简单看下代码吧：123&lt;div id=&quot;app&quot;&gt; &lt;my-button @greet=&quot;sayHi&quot;&gt;&lt;/my-button&gt; &lt;/div&gt; 12345678910111213141516171819202122232425 复制代码let MyButton = Vue.extend(&#123; template: &apos;&lt;button @click=&quot;triggerClick&quot;&gt;click&lt;/button&gt;&apos;, data () &#123; return &#123; greeting: &apos;vue.js!&apos; &#125; &#125;, methods: &#123; triggerClick () &#123; this.$emit(&apos;greet&apos;, this.greeting) &#125; &#125;&#125;)new Vue(&#123; el: &apos;#app&apos;, components: &#123; MyButton &#125;, methods: &#123; sayHi (val) &#123; alert(&apos;Hi, &apos; + val) // &apos;Hi, vue.js!&apos; &#125; &#125;&#125;) 复制代码你可以狠狠的戳这里查看Demo! 大致逻辑是酱婶儿的：当我在页面上点击按钮时，触发了组件 MyButton 上的监听事件 greet，并且把参数传给了回调函数 sayHi 。说白了，当我们从子组件 Emit（派发） 一个事件之前，其内部都提前在事件队列中 On（监听）了这个事件及其监听回调。其实相当于下面这种写法：12345vm.$on(&apos;greet&apos;, function sayHi (val) &#123; console.log(&apos;Hi, &apos; + val)&#125;)vm.$emit(&apos;greet&apos;, &apos;vue.js&apos;)// =&gt; &quot;Hi, vue.js&quot; watch的特殊情况123456789101112131415161718192021222324watch: &#123;//1,全局监听 msg (newVal, oldVal) &#123; console.log(&apos;msg 改变了&apos;); &#125;,//2深入监听 // userInfo: &#123; // handler (newVal, oldVal) &#123; // console.log(&apos;userInfo 改变了&apos;); // &#125;, // deep: true//深入监听 // &#125;//3指定监听 &apos;userInfo.name&apos;: [ function () &#123; console.log(&apos;1&apos;) &#125;, function () &#123; console.log(&apos;2&apos;) &#125; ] &#125; props验证与默认值 1数组模式1props: [&apos;title&apos;], 2对象模式123456789props: &#123; // key - prop // value - 好几种写法，可以对这个prop做一些类型校验。默认值处理之类的。 // title: String, // title 字符串类型 title: &#123; type: String, default: &apos;关于页&apos; &#125;, refref 这个属性，可以写在 普通标签上，也可以写在组件标签上， 普通标签，得到是这个标签的DOM对象 组件标签，得到是这个组件的组件对象 ref 用在哪个组件上，那么就需要使用哪个组件的 refs 去获取 组件的通信的特殊处理触发事件1vm.$emit() // $emit 子 -&gt; 父 监听事件1vm.$on() 监听事件但是只监听一次1vm.$once() 除了使用 props 来做父-&gt;子 还有一些特殊的操作：（但是不怎么推荐） 1. ref 用在组件标签上 2. $root 实例属性，可以拿到根组件的对象，也就是 new Vue 出来的实例 3. $parent 实例属性，可以拿到当前组件的父组件的实例对象 4. $children 实例属性，去获取子组件的实例，得到的是一个子组件实例的集合（Array） 兄弟组件之间与复杂关系组件之间的通信事件总线 - 中央事件管理器 - bus 主要就是使用的 $on 与 $emit 通过一个空的vue实例对象来做为中央事件管理器。 动态组件1&lt;component :is=&quot;curTab&quot;&gt;&lt;/component&gt; 组件上使用v-modelv-model 其实是一种语法糖。在组件身上使用 v-model需要 v-modle 绑定的数据可以在 组件中使用，并且可以通过某种形式直接去修改它。 普通的事件并且是用在普通标签上的时候，$event 代表着事件对象 如果事件是写在 组件的标签上面，$event 代表着触发这个事件的时候传递过来的参数sync修饰符 123this.$emit(&apos;update:title&apos;, newTitle)&lt;text-document v-bind:title.sync=&quot;doc.title&quot;&gt;&lt;/text-document&gt; 插槽默认在组件开始标签与结束标签中写的内容是不会理睬的。如果需要将内容给渲染出去。就需要使用出 插槽(坑) slot 插槽模板内容： 使用组件时开始标签与闭合标签内的内容 使用顺序： 思考 你的 插槽模板内容要显示在组件 template 模板的那个位置。。 在 组件的 template 模板中 相应的位置 放置一个 slot 内置组件 效果就会是：你这个插槽模板内容会替换 slot 这个组件并渲染到页面上。一些情况： slot 是不限制次数的， slot 是可以命名的。slot 组件上 使用 name 属性给他命名哪个插槽模板内容要放到哪个 slot 坑里面，就需要带着 name 的名字 slot 还可以有个默认不加锁的 坑 插槽的作用域作用域插槽：（把组件内数据能够在插槽模板内容中使用） 使用步骤： 在 slot 标签上，写 自定义的属性，注意不能是 name2. 在 相应的 slot 的插槽模板内容上面 使用 slot-scope 接收 第一步中传递过来的 porp 集合。 插槽的新语法旧的写法1&lt;p slot=&quot;abc&quot;&gt;我的天&lt;/p&gt; 新的写法123&lt;template v-slot:abc&gt;&lt;p&gt;我的地&lt;/p&gt;&lt;/template&gt; 一个不带 name 的 出口会带有隐含的名字“default”v-slot:可以简写成#v-slot 只能添加在一个 上 (只有一种例外情况)，这一点和已经废弃的 slot 特性不同。 非prop的特性非props特性: (在使用的组件的时候，在组件标签上写的特性，如果组件内部没有通过props选项去指定，那么这个 特性就叫做 非props特性), 非props特性会自动写入到组件的根元素上非props特性替换的情况:合并的情况：（class yu style）禁用非props特性的自动写入到组件根元素上这个规则， 但是 class 与 style 除外。 $attrs 与我们 inheritAttrs 没有关系。 $attrs 与 inheritAttrs 结合起来使用可以帮我们做一些事情，把这些非props特性写到组件的其他元素上。基础组件：（将项目常用的一些基础html标签给做一个简单的封装。 生命周期图 AxiosAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 执行 GET 请求// 为给定 ID 的 user 创建请求1234567891011121314151617181920axios.get(&apos;/user?ID=12345&apos;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 可选地，上面的请求可以这样做axios.get(&apos;/user&apos;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 12345678910执行 POST 请求axios.post(&apos;/user&apos;, &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 可以通过向 axios 传递相关配置来创建请求axios(config)//1234567发送 POST 请求axios(&#123;method: &apos;post&apos;, url: &apos;/user/12345&apos;, data: &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;&#125;);]]></content>
      <tags>
        <tag>vue基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript运行机制]]></title>
    <url>%2F2019%2F05%2F16%2FJavaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[你真懂JavaScript运行机制吗1？说起javascript（以下简称js）这门语言，相信大家已经非常熟悉了，不管是前端开发还是后端开发几乎无时无刻都要跟它打交道。虽说开发者每天几乎都要操作js，但是你真的确定你掌握了js的运行机制吗！下面我们就来聊聊这话题。 JavaScript运行机制图解上图我们可以分为两部分：浏览器中的 JS引擎 和 运行环境Runtime ，那它们的区别是什么？ JS引擎：编译并执行代码的地方。如上图中可以看出JS引擎分为两大核心部分： 栈和堆栈（Stack）:js代码的执行都要压到此栈中执行。堆：存放对象、数组的地方，js垃圾回收就是检查这里。 Runtime：浏览器的运行环境，它提供了一些对外接口供JS调用，以及跟外界打交道。 JavaScript引擎是单线程JS引擎是单线程的，也就是说在一个时间段内，事情只能一件一件的按先后顺序去做，第一件事没做完就不能第二件事。那么在js引擎中负责解释和执行js代码的线程只有一个，我们可以称之为 主线程 。当然浏览器的运行环境Runtime还提供一些其他的线程，如定时器线程、ajax线程、事件线程、网络请求和UI渲染的线程，为了和js主线程分开，我们这里都统称它们为 工作线程 。由于浏览器是多线程的，所以工作线程和js主线程都可以执行任务，线程间互不干扰。 JavaScript引擎是单线程JS引擎是单线程的，也就是说在一个时间段内，事情只能一件一件的按先后顺序去做，第一件事没做完就不能第二件事。那么在js引擎中负责解释和执行js代码的线程只有一个，我们可以称之为 主线程 。当然浏览器的运行环境Runtime还提供一些其他的线程，如定时器线程、ajax线程、事件线程、网络请求和UI渲染的线程，为了和js主线程分开，我们这里都统称它们为 工作线程 。由于浏览器是多线程的，所以工作线程和js主线程都可以执行任务，线程间互不干扰。 JavaScript同步（异步）任务在JavaScript任务可以分为两种： 同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务，若前一个任务耗费很长时间，则后面的任务会一直处于等待状态，即阻塞状态。 异步任务：在栈执行代码的过程中，如遇到异步函数，如setTimeout、异步Ajax、事件处理程序，会将这些异步代码交给浏览器的工作线程来处理，我们把这些任务称之为异步任务。异步任务是不进入主线程，而是进入任务队列（queue task）。 什么异步函数？异步函数通常是由发起函数和回调函数构成的。如：A（callback） 函数A就是发起函数 callback就是回调函数它们都是在主线程调用的，其中发起函数用来发起异步过程，回调函数用来处理结果。如：setTimeout(callback,1000)setTimeout就是发起函数、callback就是回调函数。 如： 异步的Ajax1234var xhr = new new XMLHttpRequest();xhr.onreadystatechange = callback; //callback为回调函数xhr.open(&apos;get&apos;,url,true);xhr.send(null); // send为发起函数 可以看出发起函数和回调函数也可以是分离的。 既然同步任务是在主线程中执行的，那么异步任务何时执行？答：是这样的，一旦栈中同步任务执行完毕后，系统就会通过 事件循环 机制读取任务队列中的任务一个个移到栈中去执行。 事件循环当主线程中的任务执行完毕后，会从任务队列中获取任务一个个的放在栈中执行去执行，这个过程是循环不断的，所以整个的这种运行机制又称为事件循环。 栈在js中，代码最终都是在栈中执行的，栈结构的特点是：先进后出，后进先出。我们来看下面代码的运行结果：1234567891011121314function bar()&#123;console.log(1);foo();&#125;function foo()&#123;par();console.log(3);&#125;function par()&#123;setTimeout(function()&#123;console.log(2);&#125;,0);&#125;bar(); 运行的最终结果是：132。 为什么结果不是123呢？下我们来分析下代码运行时入栈和出栈的过程。 首先当调用函数 bar() 时，此函数就会先入栈，其内部的 console.log(1) 也会随之入栈执行。执行完console.log(1)后，就要出栈，于是控制台先打印出结果1，只剩下bar()在栈中。接着再执行函数bar内部的函数foo，于是函数foo也开心的入栈了。执行函数foo的内部代码，调用函数 par() ，于是函数par()也要跟着入栈。由于函数par()内部执行遇到了 异步函数setTimeout ,异步函数则会由浏览器的Runtime运行环境的工作线程来处理，等定时器设置的时间到达就会被放到任务队列中，此时栈的同步任务继续执行。接着在执行par函数中的 console.log(3) ,控制台打印结果为3 ,此时栈的代码执行完毕后，会按照栈的特点进行先进后出，后进先出顺序进行 出栈 。出栈顺序：先函数par()—-》后函数foo()—-》最后函数bar. 最后只剩下异步任务，由主线程去获取任务队列中的任务放在栈中去执行。也可以认为栈中的同步代码执行总是在读取 异步任务 之前执行。最后执行setTimeout中的回调函数：结果控制台输出为2。123setTimeout(function()&#123;console.log(2);&#125;,0); 所以最终代码的运行结果为132。 小结 js引擎是单线程执行js代码，同步任务在栈中按顺序执行，如果某一个同步任务没有执行完毕，则后面的代码将会处于阻塞等待状态 栈中若执行遇到了异步任务（如定时器、异步Ajax、事件），会将此异步任务通过浏览器对应的工作线程来处理。 工作线程中的所有异步任务均会按照设定的时间进行等待，时间一到会被加入任务队列。如果是异步ajax,则等待其返回结果在加入到任务队列 当栈中为空时，会通过事件循环来一个个获取任务队列中的任务放到栈中进行逐个运行。即栈中的同步任务总是在读取 异步任务 之前执行 定时器设置的时间不一定按照设定的时间进行执行，这得取决于栈中同步任务耗费的时间。因为栈中执行的同步任务如果耗费很长时间，则会影响到异步任务回调函数的执行。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
